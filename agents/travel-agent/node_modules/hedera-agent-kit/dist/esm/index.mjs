// src/shared/api.ts
var HederaAgentAPI = class {
  client;
  context;
  tools;
  constructor(client, context, tools) {
    this.client = client;
    if (!this.client.ledgerId) {
      throw new Error("Client must be connected to a network");
    }
    this.context = context || {};
    this.tools = tools || [];
  }
  async run(method, arg) {
    const tool48 = this.tools.find((t) => t.method === method);
    if (tool48) {
      const output = JSON.stringify(await tool48.execute(this.client, this.context, arg));
      return output;
    } else {
      throw new Error("Invalid method " + method);
    }
  }
};
var api_default = HederaAgentAPI;

// src/shared/configuration.ts
var AgentMode = /* @__PURE__ */ ((AgentMode2) => {
  AgentMode2["AUTONOMOUS"] = "autonomous";
  AgentMode2["RETURN_BYTES"] = "returnBytes";
  return AgentMode2;
})(AgentMode || {});

// src/shared/parameter-schemas/token.zod.ts
import { z as z2 } from "zod";
import {
  AccountId as AccountId2,
  NftId,
  PublicKey as PublicKey2,
  TokenId,
  TokenNftAllowance,
  TokenSupplyType,
  TokenType
} from "@hashgraph/sdk";

// src/shared/parameter-schemas/common.zod.ts
import { z } from "zod";
import { AccountId, PublicKey, Timestamp } from "@hashgraph/sdk";
var optionalScheduledTransactionParams = (_context = {}) => z.object({
  schedulingParams: z.object({
    isScheduled: z.boolean().optional().default(false).describe(
      "If true, the transaction will be created as a scheduled transaction. If false or omitted, all other scheduling parameters will be ignored."
    ),
    adminKey: z.union([z.boolean(), z.string()]).optional().default(false).describe(
      "Admin key that can delete or modify the scheduled transaction before execution. If true, the operator key will be used. If false or omitted, no admin key is set. If a string is passed, it will be used as the admin key."
    ),
    payerAccountId: z.string().optional().describe(
      "Account that will pay the transaction fee when the scheduled transaction executes. Defaults to the ${AccountResolver.getDefaultAccountDescription(context)}."
    ),
    expirationTime: z.string().optional().describe(
      "Time when the scheduled transaction will expire if not fully signed (ISO 8601 format)."
    ),
    waitForExpiry: z.boolean().optional().default(false).describe(
      "If true, the scheduled transaction will be executed at its expiration time, regardless of when all required signatures are collected. If false, the transaction will execute as soon as all required signatures are present. Requires expirationTime being set, otherwise throws an error. Defaults to false."
    )
  }).optional().describe(
    "Optional scheduling parameters. Used to control whether the transaction should be scheduled, provide metadata, control payer/admin keys, and manage execution/expiration behavior."
  )
});

// src/shared/parameter-schemas/token.zod.ts
var createFungibleTokenParameters = (_context = {}) => optionalScheduledTransactionParams(_context).extend({
  tokenName: z2.string().describe("The name of the token."),
  tokenSymbol: z2.string().describe("The symbol of the token."),
  initialSupply: z2.number().int().optional().default(0).describe("The initial supply of the token."),
  supplyType: z2.enum(["finite", "infinite"]).optional().default("finite").describe("Supply type of the token."),
  maxSupply: z2.number().int().optional().describe("The maximum supply of the token."),
  decimals: z2.number().int().optional().default(0).describe("The number of decimals."),
  treasuryAccountId: z2.string().optional().describe("The treasury account of the token."),
  isSupplyKey: z2.boolean().optional().describe("Determines if the token supply key should be set.")
});
var createNonFungibleTokenParameters = (_context = {}) => optionalScheduledTransactionParams(_context).extend({
  tokenName: z2.string().describe("The name of the token."),
  tokenSymbol: z2.string().describe("The symbol of the token."),
  maxSupply: z2.number().int().optional().default(100).describe("The maximum supply of the token."),
  treasuryAccountId: z2.string().optional().describe("The treasury account of the token.")
});
var AirdropRecipientSchema = z2.object({
  accountId: z2.string().describe('Recipient account ID (e.g., "0.0.xxxx").'),
  amount: z2.union([z2.number(), z2.string()]).describe("Amount in base unit.")
});
var airdropFungibleTokenParameters = (_context = {}) => z2.object({
  tokenId: z2.string().describe("The id of the token."),
  sourceAccountId: z2.string().optional().describe("The account to airdrop the token from."),
  recipients: z2.array(AirdropRecipientSchema).min(1).describe("Array of recipient objects, each with accountId and amount.")
});
var mintFungibleTokenParameters = (_context = {}) => optionalScheduledTransactionParams(_context).extend({
  tokenId: z2.string().describe("The id of the token."),
  amount: z2.number().describe("The amount of tokens to mint.")
});
var mintNonFungibleTokenParameters = (_context = {}) => optionalScheduledTransactionParams(_context).extend({
  tokenId: z2.string().describe("The id of the NFT class."),
  uris: z2.array(z2.string().max(100)).max(10).describe("An array of URIs hosting NFT metadata.")
});
var tokenInfoQueryParameters = (_context = {}) => z2.object({
  tokenId: z2.string().optional().describe("The token ID to query.")
});
var updateTokenParameters = (_context = {}) => z2.object({
  tokenId: z2.string().describe("The ID of the token to update (e.g., 0.0.12345)."),
  tokenDesc: z2.string().optional().describe("Optional description of the token update operation."),
  tokenName: z2.string().max(100).optional().describe("New name for the token. Up to 100 characters."),
  tokenSymbol: z2.string().max(100).optional().describe("New symbol for the token. Up to 100 characters."),
  treasuryAccountId: z2.string().optional().describe("New treasury account for the token (Hedera account ID)."),
  adminKey: z2.union([z2.boolean(), z2.string()]).optional().describe(
    "New admin key. Pass boolean `true` to use the operator/user key, or provide a Hedera-compatible public key string. Required for most property updates."
  ),
  kycKey: z2.union([z2.boolean(), z2.string()]).optional().describe(
    "New KYC key. Pass boolean `true` to use the operator/user key, or provide a public key string."
  ),
  freezeKey: z2.union([z2.boolean(), z2.string()]).optional().describe(
    "New freeze key. Pass boolean `true` to use the operator/user key, or provide a public key string."
  ),
  wipeKey: z2.union([z2.boolean(), z2.string()]).optional().describe(
    "New wipe key. Pass boolean `true` to use the operator/user key, or provide a public key string."
  ),
  supplyKey: z2.union([z2.boolean(), z2.string()]).optional().describe(
    "New supply key. Pass boolean `true` to use the operator/user key, or provide a public key string."
  ),
  feeScheduleKey: z2.union([z2.boolean(), z2.string()]).optional().describe(
    "New fee schedule key. Pass boolean `true` to use the operator/user key, or provide a public key string."
  ),
  pauseKey: z2.union([z2.boolean(), z2.string()]).optional().describe(
    "New pause key. Pass boolean `true` to use the operator/user key, or provide a public key string."
  ),
  metadataKey: z2.union([z2.boolean(), z2.string()]).optional().describe(
    "New metadata key. Pass boolean `true` to use the operator/user key, or provide a public key string."
  ),
  metadata: z2.string().optional().describe("New metadata for the token, in bytes (as base64 or hex)."),
  tokenMemo: z2.string().max(100).optional().describe("Short public memo for the token, up to 100 characters."),
  autoRenewAccountId: z2.string().optional().describe("Account to automatically pay for token renewal (Hedera account ID).")
});
var associateTokenParameters = (_context = {}) => z2.object({
  // If not passed, will be injected from context in normalisation
  accountId: z2.string().optional().describe(
    "Account ID to associate tokens with (e.g., 0.0.xxxxx). If not provided, operator account ID will be used"
  ),
  // One or more token IDs to associate
  tokenIds: z2.array(z2.string()).min(1).describe("Array of token IDs to associate")
});
var pendingAirdropQueryParameters = (_context = {}) => z2.object({
  accountId: z2.string().optional().describe("The account ID to query.")
});
var dissociateTokenParameters = (_context = {}) => z2.object({
  tokenIds: z2.array(z2.string()).min(1).describe("The list of Hedera token IDs (strings) to dissociate. Must provide at least one."),
  accountId: z2.string().optional().describe(
    "The account ID from which to dissociate the tokens. Defaults to operator account."
  ),
  transactionMemo: z2.string().optional().describe("Optional memo for the transaction.")
});
var approveNftAllowanceParameters = (_context = {}) => z2.object({
  ownerAccountId: z2.string().optional().describe("Owner account ID (defaults to operator account ID if omitted)"),
  spenderAccountId: z2.string().describe("Spender account ID"),
  tokenId: z2.string().describe("The NFT token ID"),
  allSerials: z2.boolean().optional().describe(
    "If true, approve allowance for all current and future serials of the NFT collection. If true, do not provide serialNumbers."
  ),
  serialNumbers: z2.array(z2.number().int().nonnegative()).optional().describe("Array of NFT serial numbers to approve. Required if allSerials is not true."),
  transactionMemo: z2.string().optional().describe("Memo to include with the transaction")
}).superRefine((val, ctx) => {
  const all = !!val.allSerials;
  const serials = val.serialNumbers ?? [];
  if (all && serials.length > 0) {
    ctx.addIssue({
      code: z2.ZodIssueCode.custom,
      message: "When approving for all serials (allSerials=true), serialNumbers must not be provided.",
      path: ["serialNumbers"]
    });
  }
  if (!all && serials.length === 0) {
    ctx.addIssue({
      code: z2.ZodIssueCode.custom,
      message: "serialNumbers must contain at least one serial when allSerials is not true.",
      path: ["serialNumbers"]
    });
  }
});
var transferNonFungibleTokenWithAllowanceParameters = (_context) => z2.object({
  sourceAccountId: z2.string().describe("Account ID of the token owner (the allowance granter)"),
  tokenId: z2.string().describe('The NFT token ID (e.g. "0.0.12345")'),
  recipients: z2.array(
    z2.object({
      recipientId: z2.string().describe("Account ID of the recipient"),
      serialNumber: z2.number().positive().describe("Serial number of the NFT to transfer")
    })
  ).min(1).describe("Array of recipient and NFT serial number pairs to transfer"),
  transactionMemo: z2.string().optional().describe("Optional memo to include with the transaction")
}).superRefine((val, ctx) => {
  const seenSerials = /* @__PURE__ */ new Set();
  for (const { serialNumber } of val.recipients) {
    if (seenSerials.has(serialNumber)) {
      ctx.addIssue({
        code: z2.ZodIssueCode.custom,
        message: `Duplicate serial number: ${serialNumber}`,
        path: ["recipients"]
      });
    }
    seenSerials.add(serialNumber);
  }
});
var transferFungibleTokenWithAllowanceParameters = (context = {}) => optionalScheduledTransactionParams(context).extend({
  tokenId: z2.string().describe("Token ID to transfer"),
  sourceAccountId: z2.string().describe("Account ID of the token owner (the allowance granter)"),
  transfers: z2.array(
    z2.object({
      accountId: z2.string().describe("Recipient account ID"),
      amount: z2.number().nonnegative().describe("Amount of tokens to transfer in display unit.")
    })
  ).min(1).describe("Array of recipient transfers"),
  transactionMemo: z2.string().optional().describe("Memo for the transaction")
});

// src/shared/parameter-schemas/account.zod.ts
import { z as z3 } from "zod";
import { AccountId as AccountId3, Hbar, Key, HbarAllowance, TokenAllowance } from "@hashgraph/sdk";
import BigNumber from "bignumber.js";
import Long from "long";
var transferHbarParameters = (context = {}) => optionalScheduledTransactionParams(context).extend({
  transfers: z3.array(
    z3.object({
      accountId: z3.string().describe("Recipient account ID"),
      amount: z3.number().describe("Amount of HBAR to transfer")
    })
  ).describe("Array of HBAR transfers").min(1),
  sourceAccountId: z3.string().optional().describe("Account ID of the HBAR owner \u2014 the balance will be deducted from this account"),
  transactionMemo: z3.string().optional().describe("Memo to include with the transaction")
});
var createAccountParameters = (_context = {}) => optionalScheduledTransactionParams(_context).extend({
  publicKey: z3.string().optional().describe("Account public key. If not provided, the operator\u2019s public key will be used."),
  accountMemo: z3.string().optional().describe("Optional memo for the account."),
  initialBalance: z3.number().optional().default(0).describe("Initial HBAR balance to fund the account (defaults to 0)."),
  maxAutomaticTokenAssociations: z3.number().optional().default(-1).describe("Max automatic token associations (-1 for unlimited).")
});
var deleteAccountParameters = (_context = {}) => z3.object({
  accountId: z3.string().describe("The account ID to delete."),
  transferAccountId: z3.string().optional().describe(
    "The ID of the account to transfer the remaining funds to. If not provided, the operator account ID will be used."
  )
});
var updateAccountParameters = (_context = {}) => optionalScheduledTransactionParams(_context).extend({
  // If not passed, will be injected from context in normalization
  accountId: z3.string().optional().describe(
    "Account ID to update (e.g., 0.0.xxxxx). If not provided, operator account ID will be used"
  ),
  maxAutomaticTokenAssociations: z3.number().int().optional().describe("Max automatic token associations, positive, zero or -1 if unlimited"),
  stakedAccountId: z3.string().optional().describe("Staked account ID"),
  accountMemo: z3.string().optional().describe("Account memo"),
  declineStakingReward: z3.boolean().optional().describe("Decline staking rewards")
});
var accountQueryParameters = (_context = {}) => z3.object({
  accountId: z3.string().describe("The account ID to query.")
});
var accountBalanceQueryParameters = (_context = {}) => z3.object({
  accountId: z3.string().optional().describe("The account ID to query.")
});
var accountTokenBalancesQueryParameters = (_context = {}) => z3.object({
  accountId: z3.string().optional().describe("The account ID to query. If not provided, this accountId will be used."),
  tokenId: z3.string().optional().describe("The token ID to query.")
});
var signScheduleTransactionParameters = (_context = {}) => z3.object({
  scheduleId: z3.string().describe("The ID of the scheduled transaction to sign")
});
var scheduleDeleteTransactionParameters = (_context = {}) => z3.object({
  scheduleId: z3.string().describe("The ID of the scheduled transaction to delete")
});
var approveHbarAllowanceParameters = (_context = {}) => z3.object({
  ownerAccountId: z3.string().optional().describe("Owner account ID (defaults to operator account ID if omitted)"),
  spenderAccountId: z3.string().describe("Spender account ID"),
  amount: z3.number().describe("Amount of HBAR to approve as allowance (can be decimal, not negative)"),
  transactionMemo: z3.string().optional().describe("Memo to include with the transaction")
});
var approveTokenAllowanceParameters = (_context = {}) => z3.object({
  ownerAccountId: z3.string().optional().describe("Owner account ID (defaults to operator account ID if omitted)"),
  spenderAccountId: z3.string().describe("Spender account ID"),
  tokenApprovals: z3.array(
    z3.object({
      tokenId: z3.string().describe("Token ID"),
      amount: z3.number().nonnegative().describe("Amount of tokens to approve (must be positive integer)")
    })
  ).min(1).describe("List of token allowances to approve"),
  transactionMemo: z3.string().optional().describe("Memo to include with the transaction")
});
var transferHbarWithAllowanceParameters = transferHbarParameters;
var deleteHbarAllowanceParameters = (_context = {}) => z3.object({
  ownerAccountId: z3.string().optional().describe("Owner account ID (defaults to operator account ID if omitted)"),
  spenderAccountId: z3.string().describe("Spender account ID"),
  transactionMemo: z3.string().optional().describe("Memo to include with the transaction")
});
var deleteTokenAllowanceParameters = (_context = {}) => z3.object({
  ownerAccountId: z3.string().optional(),
  spenderAccountId: z3.string(),
  tokenIds: z3.array(z3.string()),
  // list of token IDs whose allowances weâ€™re deleting
  transactionMemo: z3.string().optional()
});

// src/shared/parameter-schemas/consensus.zod.ts
import { z as z4 } from "zod";
import { AccountId as AccountId4, PublicKey as PublicKey3, TopicId } from "@hashgraph/sdk";
var getTopicInfoParameters = (_context = {}) => {
  return z4.object({
    topicId: z4.string().describe("The topic ID to query.")
  });
};
var createTopicParameters = (_context = {}) => {
  return z4.object({
    isSubmitKey: z4.boolean().optional().default(false).describe("Whether to set a submit key for the topic (optional)"),
    topicMemo: z4.string().optional().describe("Memo for the topic (optional)"),
    transactionMemo: z4.string().optional().describe("An optional memo to include on the submitted transaction (optional).")
  });
};
var submitTopicMessageParameters = (_context = {}) => optionalScheduledTransactionParams(_context).extend({
  topicId: z4.string().describe("The ID of the topic to submit the message to"),
  message: z4.string().describe("The message to submit to the topic"),
  transactionMemo: z4.string().optional().describe("An optional memo to include on the submitted transaction (optional).")
});
var deleteTopicParameters = (_context = {}) => z4.object({
  topicId: z4.string().describe("The ID of the topic to delete.")
});
var deleteTopicParametersNormalised = (_context = {}) => deleteTopicParameters(_context).extend({});
var topicMessagesQueryParameters = (_context = {}) => z4.object({
  topicId: z4.string().describe("The topic ID to query."),
  startTime: z4.string().datetime().optional().describe(
    "The start time to query. If set, the messages will be returned after this timestamp."
  ),
  endTime: z4.string().datetime().optional().describe(
    "The end time to query. If set, the messages will be returned before this timestamp."
  ),
  limit: z4.number().optional().describe("The limit of messages to query. If set, the number of messages to return.")
});
var updateTopicParameters = (_context = {}) => z4.object({
  topicId: z4.string().describe("The ID of the topic to update (e.g., 0.0.12345)."),
  topicMemo: z4.string().optional().describe("Optional new memo for the topic."),
  adminKey: z4.union([z4.boolean(), z4.string()]).optional().describe(
    "New admin key. Pass boolean `true` to use the operator/user key, or provide a Hedera-compatible public key string."
  ),
  submitKey: z4.union([z4.boolean(), z4.string()]).optional().describe(
    "New submit key. Pass boolean `true` to use the operator/user key, or provide a Hedera-compatible public key string."
  ),
  autoRenewAccountId: z4.string().optional().describe("Account to automatically pay for topic renewal (Hedera account ID)."),
  autoRenewPeriod: z4.number().optional().describe("Auto renew period in seconds."),
  expirationTime: z4.union([z4.string(), z4.instanceof(Date)]).optional().describe("New expiration time for the topic (ISO string or Date).")
});

// src/shared/hedera-utils/hedera-parameter-normaliser.ts
import {
  AccountId as AccountId5,
  Hbar as Hbar2,
  Long as Long2,
  PublicKey as PublicKey5,
  TokenId as TokenId2,
  TokenNftAllowance as TokenNftAllowance2,
  TokenSupplyType as TokenSupplyType2,
  TokenType as TokenType2,
  TopicId as TopicId2,
  HbarAllowance as HbarAllowance2,
  TokenAllowance as TokenAllowance2,
  Timestamp as Timestamp2,
  NftId as NftId2
} from "@hashgraph/sdk";
import z7 from "zod";

// src/shared/hedera-utils/decimals-utils.ts
import BigNumber2 from "bignumber.js";
function toBaseUnit(amount, decimals) {
  const amountBN = new BigNumber2(amount);
  const multiplier = new BigNumber2(10).pow(decimals);
  return amountBN.multipliedBy(multiplier).integerValue(BigNumber2.ROUND_FLOOR);
}
function toDisplayUnit(baseAmount, decimals) {
  const baseAmountBN = new BigNumber2(baseAmount);
  const divisor = new BigNumber2(10).pow(decimals);
  return baseAmountBN.dividedBy(divisor);
}

// src/shared/utils/account-resolver.ts
import { PublicKey as PublicKey4 } from "@hashgraph/sdk";

// src/shared/hedera-utils/mirrornode/types.ts
import { LedgerId } from "@hashgraph/sdk";
var LedgerIdToBaseUrl = /* @__PURE__ */ new Map([
  [LedgerId.MAINNET.toString(), "https://mainnet-public.mirrornode.hedera.com/api/v1"],
  [LedgerId.TESTNET.toString(), "https://testnet.mirrornode.hedera.com/api/v1"]
]);

// src/shared/hedera-utils/mirrornode/hedera-mirrornode-service-default-impl.ts
import BigNumber3 from "bignumber.js";
var HederaMirrornodeServiceDefaultImpl = class {
  constructor(ledgerId) {
    this.ledgerId = ledgerId;
    if (!LedgerIdToBaseUrl.has(ledgerId.toString())) {
      throw new Error(`Network type ${ledgerId} not supported`);
    }
    this.baseUrl = LedgerIdToBaseUrl.get(ledgerId.toString());
  }
  baseUrl;
  async getAccount(accountId) {
    const url = `${this.baseUrl}/accounts/${accountId}`;
    const response = await fetch(url);
    if (!response.ok) {
      throw new Error(
        `Failed to fetch account ${accountId}: ${response.status} ${response.statusText}`
      );
    }
    const data = await response.json();
    if (!data.account) {
      throw new Error(`Account ${accountId} not found`);
    }
    return {
      accountId: data.account,
      accountPublicKey: data?.key?.key,
      balance: data.balance,
      evmAddress: data.evm_address
    };
  }
  async getAccountHbarBalance(accountId) {
    let account;
    try {
      account = await this.getAccount(accountId);
    } catch (error) {
      throw Error(`Failed to fetch hbar balance for ${accountId}: ${error}`);
    }
    return new BigNumber3(account.balance.balance);
  }
  async getAccountTokenBalances(accountId, tokenId) {
    const tokenIdParam = tokenId ? `&token.id=${tokenId}` : "";
    const url = `${this.baseUrl}/accounts/${accountId}/tokens?${tokenIdParam}`;
    const response = await fetch(url);
    if (!response.ok) {
      throw new Error(
        `Failed to fetch balance for account ${accountId}: ${response.status} ${response.statusText}`
      );
    }
    const res = await response.json();
    await Promise.all(
      res.tokens.map(async (balance) => {
        try {
          const tokenInfo = await this.getTokenInfo(balance.token_id);
          balance.symbol = tokenInfo.symbol;
        } catch (err) {
          console.warn(`Failed to fetch token info for ${balance.token_id}:`, err);
          balance.symbol = "UNKNOWN";
        }
      })
    );
    return res;
  }
  async getTopicMessages(queryParams) {
    const lowerThreshold = queryParams.lowerTimestamp ? `&timestamp=gte:${queryParams.lowerTimestamp}` : "";
    const upperThreshold = queryParams.upperTimestamp ? `&timestamp=lte:${queryParams.upperTimestamp}` : "";
    const baseParams = `&order=desc&limit=100`;
    let url = `${this.baseUrl}/topics/${queryParams.topicId}/messages?${lowerThreshold}${upperThreshold}${baseParams}`;
    const arrayOfMessages = [];
    let fetchedMessages = 0;
    try {
      while (url) {
        fetchedMessages += 1;
        const response = await fetch(url);
        if (!response.ok) {
          throw new Error(
            `Failed to get topic messages for ${queryParams.topicId}: ${response.status} ${response.statusText}`
          );
        }
        const data = await response.json();
        arrayOfMessages.push(...data.messages);
        if (fetchedMessages >= 100) {
          break;
        }
        url = data.links.next ? this.baseUrl + data.links.next : null;
      }
    } catch (error) {
      console.error(`Failed to fetch topic messages for ${queryParams.topicId}. Error:`, error);
      throw error;
    }
    return {
      topicId: queryParams.topicId,
      messages: arrayOfMessages.slice(0, queryParams.limit)
    };
  }
  async getTokenInfo(tokenId) {
    const url = `${this.baseUrl}/tokens/${tokenId}`;
    const response = await fetch(url);
    if (!response.ok) {
      throw new Error(
        `Failed to get token info for a token ${tokenId}: ${response.status} ${response.statusText}`
      );
    }
    return await response.json();
  }
  async getTopicInfo(topicId) {
    const url = `${this.baseUrl}/topics/${topicId}`;
    const response = await fetch(url);
    if (!response.ok) {
      throw new Error(
        `Failed to get topic info for ${topicId}: ${response.status} ${response.statusText}`
      );
    }
    return await response.json();
  }
  async getTransactionRecord(transactionId, nonce) {
    let url = `${this.baseUrl}/transactions/${transactionId}`;
    if (nonce !== void 0) {
      url += `?nonce=${nonce}`;
    }
    const response = await fetch(url);
    if (!response.ok) {
      throw new Error(
        `Failed to get transaction record for ${transactionId}: ${response.status} ${response.statusText}`
      );
    }
    return await response.json();
  }
  async getContractInfo(contractId) {
    const url = `${this.baseUrl}/contracts/${contractId}`;
    const response = await fetch(url);
    if (!response.ok) {
      throw new Error(
        `Failed to get contract info for ${contractId}: ${response.status} ${response.statusText}`
      );
    }
    return await response.json();
  }
  async getPendingAirdrops(accountId) {
    const url = `${this.baseUrl}/accounts/${accountId}/airdrops/pending`;
    const response = await fetch(url);
    if (!response.ok) {
      throw new Error(
        `Failed to fetch pending airdrops for an account ${accountId}: ${response.status} ${response.statusText}`
      );
    }
    return await response.json();
  }
  async getOutstandingAirdrops(accountId) {
    const url = `${this.baseUrl}/accounts/${accountId}/airdrops/outstanding`;
    const response = await fetch(url);
    if (!response.ok) {
      throw new Error(
        `Failed to fetch outstanding airdrops for an account ${accountId}: ${response.status} ${response.statusText}`
      );
    }
    return await response.json();
  }
  async getExchangeRate(timestamp) {
    const timestampParam = timestamp ? `?timestamp=${encodeURIComponent(timestamp)}` : "";
    const url = `${this.baseUrl}/network/exchangerate${timestampParam}`;
    const response = await fetch(url);
    if (!response.ok) {
      throw new Error(`HTTP error! status: ${response.status}. Message: ${response.statusText}`);
    }
    return await response.json();
  }
  async getTokenAllowances(ownerAccountId, spenderAccountId) {
    const url = `${this.baseUrl}/accounts/${ownerAccountId}/allowances/tokens?spender.id=${spenderAccountId}`;
    const response = await fetch(url);
    if (!response.ok) {
      throw new Error(`HTTP error! status: ${response.status}. Message: ${response.statusText}`);
    }
    return await response.json();
  }
  async getAccountNfts(ownerAccountId) {
    const url = `${this.baseUrl}/accounts/${ownerAccountId}/nfts`;
    const response = await fetch(url);
    if (!response.ok) {
      throw new Error(`HTTP error! status: ${response.status}. Message: ${response.statusText}`);
    }
    return await response.json();
  }
  async getScheduledTransactionDetails(scheduleId) {
    const url = `${this.baseUrl}/schedules/${scheduleId}`;
    const response = await fetch(url);
    if (!response.ok) {
      throw new Error(`HTTP error! status: ${response.status}. Message: ${response.statusText}`);
    }
    return await response.json();
  }
};

// src/shared/hedera-utils/mirrornode/hedera-mirrornode-utils.ts
var getMirrornodeService = (mirrornodeService, ledgerId) => {
  if (mirrornodeService) {
    return mirrornodeService;
  }
  return new HederaMirrornodeServiceDefaultImpl(ledgerId);
};

// src/shared/utils/account-resolver.ts
var AccountResolver = class _AccountResolver {
  /**
   * Gets the default account based on the agent mode and context.
   * In RETURN_BYTES mode, prefers context.accountId (user's account).
   * In AUTONOMOUS mode or when no context account, uses an operator account.
   */
  static getDefaultAccount(context, client) {
    if (context.accountId) {
      return context.accountId;
    }
    const operatorAccount = client.operatorAccountId?.toString();
    if (!operatorAccount) {
      throw new Error("No account available: neither context.accountId nor operator account");
    }
    return operatorAccount;
  }
  static async getDefaultPublicKey(context, client) {
    if (context.mode === "autonomous" /* AUTONOMOUS */) {
      return client.operatorPublicKey;
    }
    const defaultAccount = this.getDefaultAccount(context, client);
    const mirrornodeService = getMirrornodeService(context.mirrornodeService, client.ledgerId);
    const defaultAccountDetails = await mirrornodeService.getAccount(defaultAccount);
    if (!defaultAccountDetails?.accountPublicKey) {
      throw new Error("No public key available for the default account");
    }
    return PublicKey4.fromString(defaultAccountDetails.accountPublicKey);
  }
  /**
   * Resolves an account ID, using the provided account or falling back to the default.
   */
  static resolveAccount(providedAccount, context, client) {
    return providedAccount || this.getDefaultAccount(context, client);
  }
  /**
   * Gets a description of which account will be used as default for prompts.
   */
  static getDefaultAccountDescription(context) {
    if (context.mode === "returnBytes" /* RETURN_BYTES */ && context.accountId) {
      return `user account (${context.accountId})`;
    }
    return "operator account";
  }
  static isHederaAddress(address) {
    return address.startsWith("0.") || address.startsWith("0.0.");
  }
  static async getHederaEVMAddress(address, mirrorNode) {
    if (!_AccountResolver.isHederaAddress(address)) {
      return address;
    }
    const account = await mirrorNode.getAccount(address);
    return account.evmAddress;
  }
};

// src/shared/hedera-utils/hedera-parameter-normaliser.ts
import { ethers } from "ethers";

// src/shared/parameter-schemas/evm.zod.ts
import { z as z5 } from "zod";
var transferERC20Parameters = (context = {}) => optionalScheduledTransactionParams(context).extend({
  contractId: z5.string().describe("The id of the ERC20 contract."),
  recipientAddress: z5.string().describe("Address to which the tokens will be transferred."),
  amount: z5.number().describe("The amount of tokens to transfer.")
});
var createERC721Parameters = (context = {}) => optionalScheduledTransactionParams(context).extend({
  tokenName: z5.string().describe("The name of the token."),
  tokenSymbol: z5.string().describe("The symbol of the token."),
  baseURI: z5.string().default("").describe("The base URI for token metadata.")
});
var createERC20Parameters = (context = {}) => optionalScheduledTransactionParams(context).extend({
  tokenName: z5.string().describe("The name of the token."),
  tokenSymbol: z5.string().describe("The symbol of the token."),
  decimals: z5.number().int().min(0).optional().default(18).describe("The number of decimals the token supports."),
  initialSupply: z5.number().int().min(0).optional().default(0).describe("The initial supply of the token.")
});
var transferERC721Parameters = (context = {}) => optionalScheduledTransactionParams(context).extend({
  contractId: z5.string().describe("The id of the ERC721 contract."),
  fromAddress: z5.string().optional().describe("Address from which the token will be transferred."),
  toAddress: z5.string().describe("Address to which the token will be transferred."),
  tokenId: z5.number().describe("The ID of the token to transfer.")
});
var mintERC721Parameters = (context = {}) => optionalScheduledTransactionParams(context).extend({
  contractId: z5.string().describe("The id of the ERC721 contract."),
  toAddress: z5.string().optional().describe("Address to which the token will be minted.")
});
var contractInfoQueryParameters = (_context = {}) => z5.object({
  contractId: z5.string().describe("The token ID to query.")
});

// src/shared/parameter-schemas/transaction.zod.ts
import { z as z6 } from "zod";
var transactionRecordQueryParameters = (_context = {}) => {
  return z6.object({
    transactionId: z6.string().describe(
      'The transaction ID to fetch details for. Should be in format \\"shard.realm.num-sss-nnn\\" format where sss are seconds and nnn are nanoseconds'
    ),
    nonce: z6.number().nonnegative().optional().describe("Optional nonnegative nonce value for the transaction")
  });
};

// src/shared/hedera-utils/hedera-parameter-normaliser.ts
var HederaParameterNormaliser = class _HederaParameterNormaliser {
  static parseParamsWithSchema(params, schema, context = {}) {
    let parsedParams;
    try {
      parsedParams = schema(context).parse(params);
    } catch (e) {
      if (e instanceof z7.ZodError) {
        const issues = this.formatZodIssues(e);
        throw new Error(`Invalid parameters: ${issues}`);
      }
      throw e;
    }
    return parsedParams;
  }
  static formatZodIssues(error) {
    return error.errors.map((err) => `Field "${err.path.join(".")}" - ${err.message}`).join("; ");
  }
  static async normaliseCreateFungibleTokenParams(params, context, client, mirrorNode) {
    const parsedParams = this.parseParamsWithSchema(params, createFungibleTokenParameters, context);
    const defaultAccountId = AccountResolver.getDefaultAccount(context, client);
    const treasuryAccountId = parsedParams.treasuryAccountId ?? defaultAccountId;
    if (!treasuryAccountId) throw new Error("Must include treasury account ID");
    const initialSupply = toBaseUnit(
      parsedParams.initialSupply ?? 0,
      parsedParams.decimals
    ).toNumber();
    const isFinite = (parsedParams.supplyType ?? "infinite") === "finite";
    const supplyType = isFinite ? TokenSupplyType2.Finite : TokenSupplyType2.Infinite;
    const maxSupply = isFinite ? toBaseUnit(parsedParams.maxSupply ?? 1e6, parsedParams.decimals).toNumber() : void 0;
    if (maxSupply !== void 0 && initialSupply > maxSupply) {
      throw new Error(`Initial supply (${initialSupply}) cannot exceed max supply (${maxSupply})`);
    }
    const publicKey = await mirrorNode.getAccount(defaultAccountId).then((r) => r.accountPublicKey) ?? client.operatorPublicKey?.toStringDer();
    const schedulingParams = parsedParams?.schedulingParams?.isScheduled ? (await this.normaliseScheduledTransactionParams(parsedParams, context, client)).schedulingParams : { isScheduled: false };
    return {
      ...parsedParams,
      schedulingParams,
      supplyType,
      treasuryAccountId,
      maxSupply,
      initialSupply,
      autoRenewAccountId: defaultAccountId,
      supplyKey: parsedParams.isSupplyKey === true ? PublicKey5.fromString(publicKey) : void 0
    };
  }
  static async normaliseCreateNonFungibleTokenParams(params, context, client, mirrorNode) {
    const parsedParams = this.parseParamsWithSchema(params, createNonFungibleTokenParameters, context);
    const defaultAccountId = AccountResolver.getDefaultAccount(context, client);
    const treasuryAccountId = parsedParams.treasuryAccountId ?? defaultAccountId;
    if (!treasuryAccountId) throw new Error("Must include treasury account ID");
    const publicKey = await mirrorNode.getAccount(defaultAccountId).then((r) => r.accountPublicKey) ?? client.operatorPublicKey?.toStringDer();
    if (!publicKey) throw new Error("Could not determine public key for supply key");
    const maxSupply = parsedParams.maxSupply ?? 100;
    const schedulingParams = parsedParams?.schedulingParams?.isScheduled ? (await this.normaliseScheduledTransactionParams(parsedParams, context, client)).schedulingParams : { isScheduled: false };
    return {
      ...parsedParams,
      schedulingParams,
      treasuryAccountId,
      maxSupply,
      supplyKey: PublicKey5.fromString(publicKey),
      // the supply key is mandatory in the case of NFT
      supplyType: TokenSupplyType2.Finite,
      // NFTs supply must be finite
      autoRenewAccountId: defaultAccountId,
      tokenType: TokenType2.NonFungibleUnique
    };
  }
  static async normaliseTransferHbar(params, context, client) {
    const parsedParams = this.parseParamsWithSchema(params, transferHbarParameters, context);
    const sourceAccountId = AccountResolver.resolveAccount(
      parsedParams.sourceAccountId,
      context,
      client
    );
    const hbarTransfers = [];
    let totalTinybars = Long2.ZERO;
    for (const transfer of parsedParams.transfers) {
      const amount = new Hbar2(transfer.amount);
      if (amount.isNegative() || amount.toTinybars().equals(Long2.ZERO)) {
        throw new Error(`Invalid transfer amount: ${transfer.amount}`);
      }
      totalTinybars = totalTinybars.add(amount.toTinybars());
      hbarTransfers.push({
        accountId: transfer.accountId,
        amount
      });
    }
    hbarTransfers.push({
      accountId: sourceAccountId,
      amount: Hbar2.fromTinybars(totalTinybars.negate())
    });
    const schedulingParams = parsedParams?.schedulingParams?.isScheduled ? (await this.normaliseScheduledTransactionParams(parsedParams, context, client)).schedulingParams : { isScheduled: false };
    return {
      hbarTransfers,
      schedulingParams,
      transactionMemo: parsedParams.transactionMemo
    };
  }
  static normaliseTransferHbarWithAllowance(params, context, _client) {
    const parsed = this.parseParamsWithSchema(params, transferHbarWithAllowanceParameters, context);
    const hbarTransfers = [];
    let totalTinybars = Long2.ZERO;
    for (const transfer of parsed.transfers) {
      const amount = new Hbar2(transfer.amount);
      if (amount.isNegative() || amount.toTinybars().equals(Long2.ZERO)) {
        throw new Error(`Invalid transfer amount: ${transfer.amount}`);
      }
      totalTinybars = totalTinybars.add(amount.toTinybars());
      hbarTransfers.push({
        accountId: transfer.accountId,
        amount
      });
    }
    return {
      hbarTransfers,
      hbarApprovedTransfer: {
        ownerAccountId: parsed.sourceAccountId,
        amount: Hbar2.fromTinybars(totalTinybars).negated()
      },
      transactionMemo: parsed.transactionMemo
    };
  }
  static normaliseApproveHbarAllowance(params, context, client) {
    const parsedParams = this.parseParamsWithSchema(params, approveHbarAllowanceParameters, context);
    const ownerAccountId = AccountResolver.resolveAccount(
      parsedParams.ownerAccountId,
      context,
      client
    );
    const spenderAccountId = parsedParams.spenderAccountId;
    const amount = new Hbar2(parsedParams.amount);
    if (amount.isNegative()) {
      throw new Error(`Invalid allowance amount: ${parsedParams.amount}`);
    }
    return {
      hbarApprovals: [
        new HbarAllowance2({
          ownerAccountId: AccountId5.fromString(ownerAccountId),
          spenderAccountId: AccountId5.fromString(spenderAccountId),
          amount
        })
      ],
      transactionMemo: parsedParams.transactionMemo
    };
  }
  /**
   * Normalizes parameters for deleting an HBAR allowance.
   *
   * This function sets the allowance `amount` to **0**, which is the Hedera
   * convention for revoking an existing allowance. It validates and resolves
   * the provided parameters, then returns an object compatible with
   * `approveHbarAllowanceParametersNormalised`.
   * @param params
   * @param context
   * @param client
   */
  static normaliseDeleteHbarAllowance(params, context, client) {
    const parsedParams = this.parseParamsWithSchema(params, deleteHbarAllowanceParameters, context);
    const approveParams = {
      ownerAccountId: parsedParams.ownerAccountId,
      spenderAccountId: parsedParams.spenderAccountId,
      amount: 0,
      transactionMemo: parsedParams.transactionMemo
    };
    return this.normaliseApproveHbarAllowance(approveParams, context, client);
  }
  static normaliseApproveNftAllowance(params, context, client) {
    const parsedParams = this.parseParamsWithSchema(params, approveNftAllowanceParameters, context);
    const ownerAccountId = AccountResolver.resolveAccount(
      parsedParams.ownerAccountId,
      context,
      client
    );
    const spenderAccountId = parsedParams.spenderAccountId;
    const tokenId = TokenId2.fromString(parsedParams.tokenId);
    const approveAll = !!parsedParams.allSerials;
    const serials = parsedParams.serialNumbers ?? [];
    if (approveAll && serials.length > 0) {
      throw new Error(
        "When approving for all serials (allSerials=true), serialNumbers must not be provided."
      );
    }
    if (!approveAll && serials.length === 0) {
      throw new Error("serialNumbers must contain at least one serial");
    }
    const allSerialsValue = approveAll ? true : null;
    const serialNumbersValue = approveAll ? null : serials.map((serialNumber) => Long2.fromNumber(serialNumber));
    return {
      nftApprovals: [
        new TokenNftAllowance2({
          allSerials: allSerialsValue,
          delegatingSpender: null,
          ownerAccountId: AccountId5.fromString(ownerAccountId),
          spenderAccountId: AccountId5.fromString(spenderAccountId),
          tokenId,
          serialNumbers: serialNumbersValue
        })
      ],
      transactionMemo: parsedParams.transactionMemo
    };
  }
  static normaliseTransferNonFungibleTokenWithAllowance(params, context) {
    const parsedParams = this.parseParamsWithSchema(
      params,
      transferNonFungibleTokenWithAllowanceParameters,
      context
    );
    const tokenId = TokenId2.fromString(parsedParams.tokenId);
    const transfers = parsedParams.recipients.map((recipient) => ({
      nftId: new NftId2(tokenId, Number(recipient.serialNumber)),
      receiver: AccountId5.fromString(recipient.recipientId)
    }));
    return {
      sourceAccountId: AccountId5.fromString(parsedParams.sourceAccountId),
      transactionMemo: parsedParams.transactionMemo,
      transfers
    };
  }
  static async normaliseApproveTokenAllowance(params, context, client, mirrorNode) {
    const parsedParams = this.parseParamsWithSchema(params, approveTokenAllowanceParameters, context);
    const ownerAccountId = AccountResolver.resolveAccount(
      parsedParams.ownerAccountId,
      context,
      client
    );
    const spenderAccountId = parsedParams.spenderAccountId;
    const tokenAllowancesPromises = parsedParams.tokenApprovals.map(async (tokenAllowance) => {
      const tokenInfo = await mirrorNode.getTokenInfo(tokenAllowance.tokenId);
      const decimals = Number(tokenInfo.decimals);
      const safeDecimals = Number.isFinite(decimals) ? decimals : 0;
      const baseAmount = toBaseUnit(tokenAllowance.amount, safeDecimals).toNumber();
      return new TokenAllowance2({
        ownerAccountId: AccountId5.fromString(ownerAccountId),
        spenderAccountId: AccountId5.fromString(spenderAccountId),
        tokenId: TokenId2.fromString(tokenAllowance.tokenId),
        amount: Long2.fromNumber(baseAmount)
      });
    });
    return {
      transactionMemo: parsedParams.transactionMemo,
      tokenApprovals: await Promise.all(tokenAllowancesPromises)
    };
  }
  /**
   * Normalizes parameters for deleting a Fungible Token allowance.
   *
   * This function sets the allowance `amount` to **0**, which is the Hedera
   * convention for revoking an existing allowance. It validates and resolves
   * the provided parameters, then returns an object compatible with
   * `approveTokenAllowanceParametersNormalised`.
   * @param params
   * @param context
   * @param client
   * @param mirrorNode
   */
  static async normaliseDeleteTokenAllowance(params, context, client, mirrorNode) {
    const parsedParams = this.parseParamsWithSchema(params, deleteTokenAllowanceParameters, context);
    const approveParams = {
      ownerAccountId: parsedParams.ownerAccountId,
      spenderAccountId: parsedParams.spenderAccountId,
      tokenApprovals: parsedParams.tokenIds.map((tokenId) => ({ tokenId, amount: 0 })),
      transactionMemo: parsedParams.transactionMemo
    };
    return this.normaliseApproveTokenAllowance(approveParams, context, client, mirrorNode);
  }
  static async normaliseTransferFungibleTokenWithAllowance(params, context, client, mirrodnode) {
    const parsedParams = this.parseParamsWithSchema(
      params,
      transferFungibleTokenWithAllowanceParameters,
      context
    );
    const tokenInfo = await mirrodnode.getTokenInfo(parsedParams.tokenId);
    const tokenDecimals = tokenInfo.decimals;
    const tokenTransfers = [];
    let totalAmount = 0;
    for (const transfer of parsedParams.transfers) {
      totalAmount += transfer.amount;
      tokenTransfers.push({
        accountId: transfer.accountId,
        amount: toBaseUnit(transfer.amount, Number(tokenDecimals)).toNumber(),
        tokenId: parsedParams.tokenId
      });
    }
    const schedulingParams = parsedParams?.schedulingParams?.isScheduled ? (await this.normaliseScheduledTransactionParams(parsedParams, context, client)).schedulingParams : { isScheduled: false };
    return {
      schedulingParams,
      tokenId: parsedParams.tokenId,
      tokenTransfers,
      approvedTransfer: {
        ownerAccountId: parsedParams.sourceAccountId,
        amount: toBaseUnit(-totalAmount, Number(tokenDecimals)).toNumber()
      },
      transactionMemo: parsedParams.transactionMemo
    };
  }
  static async normaliseAirdropFungibleTokenParams(params, context, client, mirrorNode) {
    const parsedParams = this.parseParamsWithSchema(params, airdropFungibleTokenParameters, context);
    const sourceAccountId = AccountResolver.resolveAccount(
      parsedParams.sourceAccountId,
      context,
      client
    );
    const tokenInfo = await mirrorNode.getTokenInfo(parsedParams.tokenId);
    const tokenDecimals = parseInt(tokenInfo.decimals, 10);
    if (isNaN(tokenDecimals)) {
      throw new Error(`Invalid token decimals for token ${parsedParams.tokenId}`);
    }
    const tokenTransfers = [];
    let totalAmount = Long2.ZERO;
    for (const recipient of parsedParams.recipients) {
      const amountRaw = Number(recipient.amount);
      if (amountRaw <= 0) {
        throw new Error(`Invalid recipient amount: ${recipient.amount}`);
      }
      const amount = Long2.fromString(toBaseUnit(amountRaw, tokenDecimals).toNumber().toString());
      totalAmount = totalAmount.add(amount);
      tokenTransfers.push({
        tokenId: parsedParams.tokenId,
        accountId: recipient.accountId,
        amount
      });
    }
    tokenTransfers.push({
      tokenId: parsedParams.tokenId,
      accountId: sourceAccountId,
      amount: totalAmount.negate()
    });
    return {
      tokenTransfers
    };
  }
  static normaliseAssociateTokenParams(params, context, client) {
    const parsedParams = this.parseParamsWithSchema(params, associateTokenParameters, context);
    const accountId = AccountResolver.resolveAccount(parsedParams.accountId, context, client);
    return {
      accountId,
      tokenIds: parsedParams.tokenIds
    };
  }
  static async normaliseDissociateTokenParams(params, context, client) {
    const parsedParams = this.parseParamsWithSchema(params, dissociateTokenParameters, context);
    if (parsedParams.accountId === void 0) {
      parsedParams.accountId = AccountResolver.getDefaultAccount(context, client);
      if (!parsedParams.accountId) {
        throw new Error("Could not determine default account ID");
      }
    }
    return {
      ...parsedParams,
      accountId: AccountId5.fromString(parsedParams.accountId),
      tokenIds: parsedParams.tokenIds.map((id) => TokenId2.fromString(id))
    };
  }
  static async normaliseCreateTopicParams(params, context, client, mirrorNode) {
    const parsedParams = this.parseParamsWithSchema(params, createTopicParameters, context);
    const defaultAccountId = AccountResolver.getDefaultAccount(context, client);
    if (!defaultAccountId) throw new Error("Could not determine default account ID");
    const normalised = {
      ...parsedParams,
      autoRenewAccountId: defaultAccountId
    };
    if (parsedParams.isSubmitKey) {
      const publicKey = await mirrorNode.getAccount(defaultAccountId).then((r) => r.accountPublicKey) ?? client.operatorPublicKey?.toStringDer();
      if (!publicKey) {
        throw new Error("Could not determine public key for submit key");
      }
      normalised.submitKey = PublicKey5.fromString(publicKey);
    }
    return normalised;
  }
  static normaliseDeleteTopic(params, context, _client, _mirrorNode) {
    const parsedParams = this.parseParamsWithSchema(params, deleteTopicParameters, context);
    return this.parseParamsWithSchema(parsedParams, deleteTopicParametersNormalised, context);
  }
  static normaliseUpdateTopic = async (params, context, client) => {
    const parsedParams = this.parseParamsWithSchema(params, updateTopicParameters, context);
    const topicId = TopicId2.fromString(parsedParams.topicId);
    const userPublicKey = await AccountResolver.getDefaultPublicKey(context, client);
    const normalised = {
      topicId
    };
    const maybeKeys = {
      adminKey: parsedParams.adminKey,
      submitKey: parsedParams.submitKey
    };
    for (const [field, rawVal] of Object.entries(maybeKeys)) {
      const resolved = this.resolveKey(rawVal, userPublicKey);
      if (resolved) {
        normalised[field] = resolved;
      }
    }
    if (parsedParams.topicMemo) normalised.topicMemo = parsedParams.topicMemo;
    if (parsedParams.autoRenewAccountId)
      normalised.autoRenewAccountId = parsedParams.autoRenewAccountId;
    if (parsedParams.autoRenewPeriod) normalised.autoRenewPeriod = parsedParams.autoRenewPeriod;
    if (parsedParams.expirationTime) {
      normalised.expirationTime = parsedParams.expirationTime instanceof Date ? parsedParams.expirationTime : new Date(parsedParams.expirationTime);
    }
    return normalised;
  };
  static normaliseSubmitTopicMessage = async (params, context, client) => {
    const parsedParams = this.parseParamsWithSchema(params, submitTopicMessageParameters, context);
    const schedulingParams = parsedParams?.schedulingParams?.isScheduled ? (await this.normaliseScheduledTransactionParams(parsedParams, context, client)).schedulingParams : { isScheduled: false };
    return {
      ...parsedParams,
      schedulingParams
    };
  };
  static async normaliseCreateAccount(params, context, client, mirrorNode) {
    const parsedParams = this.parseParamsWithSchema(params, createAccountParameters, context);
    let publicKey = parsedParams.publicKey ?? client.operatorPublicKey?.toStringDer();
    if (!publicKey) {
      const defaultAccountId = AccountResolver.getDefaultAccount(context, client);
      if (defaultAccountId) {
        const account = await mirrorNode.getAccount(defaultAccountId);
        publicKey = account?.accountPublicKey;
      }
    }
    if (!publicKey) {
      throw new Error(
        "Unable to resolve public key: no param, mirror node, or client operator key available."
      );
    }
    const schedulingParams = parsedParams.schedulingParams?.isScheduled ? (await this.normaliseScheduledTransactionParams(parsedParams, context, client)).schedulingParams : { isScheduled: false };
    return {
      ...parsedParams,
      schedulingParams,
      key: PublicKey5.fromString(publicKey)
    };
  }
  static normaliseHbarBalanceParams(params, context, client) {
    const parsedParams = this.parseParamsWithSchema(params, accountBalanceQueryParameters, context);
    const accountId = AccountResolver.resolveAccount(parsedParams.accountId, context, client);
    return {
      accountId
    };
  }
  static normaliseAccountTokenBalancesParams(params, context, client) {
    const parsedParams = this.parseParamsWithSchema(params, accountTokenBalancesQueryParameters, context);
    const accountId = AccountResolver.resolveAccount(parsedParams.accountId, context, client);
    return {
      ...parsedParams,
      accountId
    };
  }
  static async normaliseCreateERC20Params(params, factoryContractId, factoryContractAbi, factoryContractFunctionName, context, client) {
    const parsedParams = this.parseParamsWithSchema(params, createERC20Parameters, context);
    const iface = new ethers.Interface(factoryContractAbi);
    const encodedData = iface.encodeFunctionData(factoryContractFunctionName, [
      parsedParams.tokenName,
      parsedParams.tokenSymbol,
      parsedParams.decimals,
      parsedParams.initialSupply
    ]);
    const functionParameters = ethers.getBytes(encodedData);
    const schedulingParams = parsedParams?.schedulingParams?.isScheduled ? (await this.normaliseScheduledTransactionParams(parsedParams, context, client)).schedulingParams : { isScheduled: false };
    return {
      ...parsedParams,
      contractId: factoryContractId,
      functionParameters,
      gas: 3e6,
      //TODO: make this configurable
      schedulingParams
    };
  }
  static async normaliseCreateERC721Params(params, factoryContractId, factoryContractAbi, factoryContractFunctionName, context, client) {
    const parsedParams = this.parseParamsWithSchema(params, createERC721Parameters, context);
    const iface = new ethers.Interface(factoryContractAbi);
    const encodedData = iface.encodeFunctionData(factoryContractFunctionName, [
      parsedParams.tokenName,
      parsedParams.tokenSymbol,
      parsedParams.baseURI
    ]);
    const functionParameters = ethers.getBytes(encodedData);
    const schedulingParams = parsedParams?.schedulingParams?.isScheduled ? (await this.normaliseScheduledTransactionParams(parsedParams, context, client)).schedulingParams : { isScheduled: false };
    return {
      ...parsedParams,
      contractId: factoryContractId,
      functionParameters,
      gas: 3e6,
      //TODO: make this configurable
      schedulingParams
    };
  }
  static async normaliseMintFungibleTokenParams(params, context, client, mirrorNode) {
    const parsedParams = this.parseParamsWithSchema(params, mintFungibleTokenParameters, context);
    const tokenInfo = await mirrorNode.getTokenInfo(parsedParams.tokenId);
    const decimals = Number(tokenInfo.decimals);
    const safeDecimals = Number.isFinite(decimals) ? decimals : 0;
    const baseAmount = toBaseUnit(parsedParams.amount, safeDecimals).toNumber();
    const schedulingParams = parsedParams?.schedulingParams?.isScheduled ? (await this.normaliseScheduledTransactionParams(parsedParams, context, client)).schedulingParams : { isScheduled: false };
    return {
      schedulingParams,
      tokenId: parsedParams.tokenId,
      amount: baseAmount
    };
  }
  static async normaliseMintNonFungibleTokenParams(params, context, client) {
    const parsedParams = this.parseParamsWithSchema(params, mintNonFungibleTokenParameters, context);
    const encoder = new TextEncoder();
    const metadata = parsedParams.uris.map((uri) => encoder.encode(uri));
    const schedulingParams = parsedParams?.schedulingParams?.isScheduled ? (await this.normaliseScheduledTransactionParams(parsedParams, context, client)).schedulingParams : { isScheduled: false };
    return {
      ...parsedParams,
      schedulingParams,
      metadata
    };
  }
  static async normaliseTransferERC20Params(params, factoryContractAbi, factoryContractFunctionName, context, mirrorNode, client) {
    const parsedParams = this.parseParamsWithSchema(params, transferERC20Parameters, context);
    const recipientAddress = await AccountResolver.getHederaEVMAddress(
      parsedParams.recipientAddress,
      mirrorNode
    );
    const contractId = await _HederaParameterNormaliser.getHederaAccountId(
      parsedParams.contractId,
      mirrorNode
    );
    const iface = new ethers.Interface(factoryContractAbi);
    const encodedData = iface.encodeFunctionData(factoryContractFunctionName, [
      recipientAddress,
      parsedParams.amount
    ]);
    const functionParameters = ethers.getBytes(encodedData);
    const schedulingParams = parsedParams?.schedulingParams?.isScheduled ? (await this.normaliseScheduledTransactionParams(parsedParams, context, client)).schedulingParams : { isScheduled: false };
    return {
      contractId,
      functionParameters,
      gas: 1e5,
      schedulingParams
    };
  }
  static async normaliseTransferERC721Params(params, factoryContractAbi, factoryContractFunctionName, context, mirrorNode, client) {
    const parsedParams = this.parseParamsWithSchema(params, transferERC721Parameters, context);
    const resolvedFromAddress = AccountResolver.resolveAccount(
      parsedParams.fromAddress,
      context,
      client
    );
    const fromAddress = await AccountResolver.getHederaEVMAddress(resolvedFromAddress, mirrorNode);
    const toAddress = await AccountResolver.getHederaEVMAddress(parsedParams.toAddress, mirrorNode);
    const contractId = await _HederaParameterNormaliser.getHederaAccountId(
      parsedParams.contractId,
      mirrorNode
    );
    const iface = new ethers.Interface(factoryContractAbi);
    const encodedData = iface.encodeFunctionData(factoryContractFunctionName, [
      fromAddress,
      toAddress,
      parsedParams.tokenId
    ]);
    const functionParameters = ethers.getBytes(encodedData);
    const schedulingParams = parsedParams?.schedulingParams?.isScheduled ? (await this.normaliseScheduledTransactionParams(parsedParams, context, client)).schedulingParams : { isScheduled: false };
    return {
      contractId,
      functionParameters,
      gas: 1e5,
      schedulingParams
    };
  }
  static async normaliseMintERC721Params(params, factoryContractAbi, factoryContractFunctionName, context, mirrorNode, client) {
    const parsedParams = this.parseParamsWithSchema(params, mintERC721Parameters, context);
    const resolvedToAddress = AccountResolver.resolveAccount(
      parsedParams.toAddress,
      context,
      client
    );
    const toAddress = await AccountResolver.getHederaEVMAddress(resolvedToAddress, mirrorNode);
    const contractId = await _HederaParameterNormaliser.getHederaAccountId(
      parsedParams.contractId,
      mirrorNode
    );
    const iface = new ethers.Interface(factoryContractAbi);
    const encodedData = iface.encodeFunctionData(factoryContractFunctionName, [toAddress]);
    const functionParameters = ethers.getBytes(encodedData);
    const schedulingParams = parsedParams?.schedulingParams?.isScheduled ? (await this.normaliseScheduledTransactionParams(parsedParams, context, client)).schedulingParams : { isScheduled: false };
    return {
      contractId,
      functionParameters,
      gas: 1e5,
      schedulingParams
    };
  }
  static normaliseDeleteAccount(params, context, client) {
    const parsedParams = this.parseParamsWithSchema(params, deleteAccountParameters, context);
    if (!AccountResolver.isHederaAddress(parsedParams.accountId)) {
      throw new Error("Account ID must be a Hedera address");
    }
    const transferAccountId = parsedParams.transferAccountId ?? AccountResolver.getDefaultAccount(context, client);
    if (!transferAccountId) {
      throw new Error("Could not determine transfer account ID");
    }
    return {
      accountId: AccountId5.fromString(parsedParams.accountId),
      transferAccountId: AccountId5.fromString(transferAccountId)
    };
  }
  static async normaliseUpdateAccount(params, context, client) {
    const parsedParams = this.parseParamsWithSchema(params, updateAccountParameters, context);
    const accountId = AccountId5.fromString(
      AccountResolver.resolveAccount(parsedParams.accountId, context, client)
    );
    const normalised = {
      accountId
    };
    if (parsedParams.maxAutomaticTokenAssociations !== void 0) {
      normalised.maxAutomaticTokenAssociations = parsedParams.maxAutomaticTokenAssociations;
    }
    if (parsedParams.stakedAccountId !== void 0) {
      normalised.stakedAccountId = parsedParams.stakedAccountId;
    }
    if (parsedParams.accountMemo !== void 0) {
      normalised.accountMemo = parsedParams.accountMemo;
    }
    if (parsedParams.declineStakingReward !== void 0) {
      normalised.declineStakingReward = parsedParams.declineStakingReward;
    }
    const schedulingParams = parsedParams?.schedulingParams?.isScheduled ? (await this.normaliseScheduledTransactionParams(parsedParams, context, client)).schedulingParams : { isScheduled: false };
    return {
      ...normalised,
      schedulingParams
    };
  }
  static normaliseGetTransactionRecordParams(params, context) {
    const parsedParams = this.parseParamsWithSchema(params, transactionRecordQueryParameters, context);
    const normalised = {
      nonce: parsedParams.nonce
    };
    if (!parsedParams.transactionId) {
      throw new Error("transactionId is required");
    }
    const mirrorNodeStyleRegex = /^\d+\.\d+\.\d+-\d+-\d+$/;
    const sdkStyleRegex = /^(\d+\.\d+\.\d+)@(\d+)\.(\d+)$/;
    if (mirrorNodeStyleRegex.test(parsedParams.transactionId)) {
      normalised.transactionId = parsedParams.transactionId;
    } else {
      const match = parsedParams.transactionId.match(sdkStyleRegex);
      if (!match) {
        throw new Error(`Invalid transactionId format: ${parsedParams.transactionId}`);
      }
      const [, accountId, seconds, nanos] = match;
      normalised.transactionId = `${accountId}-${seconds}-${nanos}`;
    }
    return normalised;
  }
  static async getHederaAccountId(address, mirrorNode) {
    if (AccountResolver.isHederaAddress(address)) {
      return address;
    }
    const account = await mirrorNode.getAccount(address);
    return account.accountId;
  }
  static async normaliseUpdateToken(params, context, client) {
    const parsedParams = this.parseParamsWithSchema(params, updateTokenParameters, context);
    const tokenId = TokenId2.fromString(parsedParams.tokenId);
    const userPublicKey = await AccountResolver.getDefaultPublicKey(context, client);
    const normalised = {
      tokenId
    };
    const maybeKeys = {
      adminKey: parsedParams.adminKey,
      supplyKey: parsedParams.supplyKey,
      wipeKey: parsedParams.wipeKey,
      freezeKey: parsedParams.freezeKey,
      kycKey: parsedParams.kycKey,
      feeScheduleKey: parsedParams.feeScheduleKey,
      pauseKey: parsedParams.pauseKey,
      metadataKey: parsedParams.metadataKey
    };
    for (const [field, rawVal] of Object.entries(maybeKeys)) {
      const resolved = this.resolveKey(rawVal, userPublicKey);
      if (resolved) {
        normalised[field] = resolved;
      }
    }
    if (parsedParams.tokenName) {
      normalised.tokenName = parsedParams.tokenName;
    }
    if (parsedParams.tokenSymbol) {
      normalised.tokenSymbol = parsedParams.tokenSymbol;
    }
    if (parsedParams.treasuryAccountId) {
      normalised.treasuryAccountId = parsedParams.treasuryAccountId;
    }
    if (parsedParams.tokenMemo) {
      normalised.tokenMemo = parsedParams.tokenMemo;
    }
    if (parsedParams.metadata) {
      normalised.metadata = new TextEncoder().encode(parsedParams.metadata);
    }
    if (parsedParams.autoRenewAccountId) {
      normalised.autoRenewAccountId = parsedParams.autoRenewAccountId;
    }
    return normalised;
  }
  static async normaliseScheduledTransactionParams(params, context, client) {
    const parsedParams = _HederaParameterNormaliser.parseParamsWithSchema(
      params,
      optionalScheduledTransactionParams,
      context
    );
    const scheduling = parsedParams.schedulingParams;
    const userPublicKey = await AccountResolver.getDefaultPublicKey(context, client);
    const adminKey = _HederaParameterNormaliser.resolveKey(scheduling?.adminKey, userPublicKey);
    const payerAccountID = scheduling?.payerAccountId ? AccountId5.fromString(scheduling?.payerAccountId) : void 0;
    const expirationTime = scheduling?.expirationTime ? Timestamp2.fromDate(scheduling?.expirationTime) : void 0;
    return {
      schedulingParams: {
        isScheduled: scheduling?.isScheduled ?? false,
        adminKey,
        payerAccountID,
        expirationTime,
        waitForExpiry: scheduling?.waitForExpiry ?? false
      }
    };
  }
  static resolveKey(rawValue, userKey) {
    if (rawValue === void 0) return void 0;
    if (typeof rawValue === "string") {
      try {
        return PublicKey5.fromStringED25519(rawValue);
      } catch {
        return PublicKey5.fromStringECDSA(rawValue);
      }
    }
    if (rawValue) {
      return userKey;
    }
    return void 0;
  }
};

// src/plugins/core-token-plugin/tools/fungible-token/airdrop-fungible-token.ts
import { Status } from "@hashgraph/sdk";

// src/shared/strategies/tx-mode-strategy.ts
import {
  AccountId as AccountId6,
  TransactionId
} from "@hashgraph/sdk";
var ExecuteStrategy = class {
  defaultPostProcess(response) {
    return JSON.stringify(response, null, 2);
  }
  async handle(tx, client, _context, postProcess47 = this.defaultPostProcess) {
    const submit = await tx.execute(client);
    const receipt = await submit.getReceipt(client);
    const rawTransactionResponse = {
      status: receipt.status.toString(),
      accountId: receipt.accountId,
      tokenId: receipt.tokenId,
      transactionId: tx.transactionId?.toString() ?? "",
      topicId: receipt.topicId,
      scheduleId: receipt.scheduleId
    };
    return {
      raw: rawTransactionResponse,
      humanMessage: postProcess47(rawTransactionResponse)
    };
  }
};
var ReturnBytesStrategy = class {
  async handle(tx, _client, context) {
    if (!context.accountId) throw new Error("\u2026");
    const id = TransactionId.generate(context.accountId);
    tx.setNodeAccountIds([new AccountId6(4), new AccountId6(5)]).setTransactionId(id).freeze();
    return { bytes: tx.toBytes() };
  }
};
var getStrategyFromContext = (context) => {
  if (context.mode === "returnBytes" /* RETURN_BYTES */) {
    return new ReturnBytesStrategy();
  }
  return new ExecuteStrategy();
};
var handleTransaction = async (tx, client, context, postProcess47) => {
  const strategy = getStrategyFromContext(context);
  return await strategy.handle(tx, client, context, postProcess47);
};

// src/shared/hedera-utils/hedera-builder.ts
import {
  AccountAllowanceApproveTransaction,
  AccountCreateTransaction,
  AccountDeleteTransaction,
  AccountId as AccountId7,
  AccountUpdateTransaction,
  ContractExecuteTransaction,
  ScheduleCreateTransaction,
  ScheduleDeleteTransaction,
  ScheduleSignTransaction,
  TokenAirdropTransaction,
  TokenAssociateTransaction,
  TokenCreateTransaction,
  TokenDeleteTransaction,
  TokenDissociateTransaction,
  TokenId as TokenId4,
  TokenMintTransaction,
  TokenUpdateTransaction,
  TopicCreateTransaction,
  TopicDeleteTransaction,
  TopicMessageSubmitTransaction,
  TopicUpdateTransaction,
  TransferTransaction
} from "@hashgraph/sdk";
var HederaBuilder = class _HederaBuilder {
  static createFungibleToken(params) {
    const tx = new TokenCreateTransaction(params);
    return _HederaBuilder.maybeWrapInSchedule(tx, params.schedulingParams);
  }
  static createNonFungibleToken(params) {
    const tx = new TokenCreateTransaction(params);
    return _HederaBuilder.maybeWrapInSchedule(tx, params.schedulingParams);
  }
  static transferHbar(params) {
    const tx = new TransferTransaction(params);
    return _HederaBuilder.maybeWrapInSchedule(tx, params.schedulingParams);
  }
  static transferNonFungibleTokenWithAllowance(params) {
    const tx = new TransferTransaction();
    for (const transfer of params.transfers) {
      tx.addApprovedNftTransfer(transfer.nftId, params.sourceAccountId, transfer.receiver);
    }
    if (params.transactionMemo) {
      tx.setTransactionMemo(params.transactionMemo);
    }
    return tx;
  }
  static transferHbarWithAllowance(params) {
    const tx = new TransferTransaction(params);
    tx.addApprovedHbarTransfer(
      params.hbarApprovedTransfer.ownerAccountId,
      params.hbarApprovedTransfer.amount
    );
    if (params.transactionMemo) {
      tx.setTransactionMemo(params.transactionMemo);
    }
    return tx;
  }
  static airdropFungibleToken(params) {
    return new TokenAirdropTransaction(params);
  }
  static transferFungibleTokenWithAllowance(params) {
    const tx = new TransferTransaction();
    tx.addApprovedTokenTransfer(
      params.tokenId,
      params.approvedTransfer.ownerAccountId,
      params.approvedTransfer.amount
    );
    for (const t of params.tokenTransfers) {
      tx.addTokenTransfer(t.tokenId, t.accountId, t.amount);
    }
    if (params.transactionMemo) {
      tx.setTransactionMemo(params.transactionMemo);
    }
    return _HederaBuilder.maybeWrapInSchedule(tx, params.schedulingParams);
  }
  static updateToken(params) {
    return new TokenUpdateTransaction(params);
  }
  static createTopic(params) {
    const { transactionMemo, ...rest } = params;
    const tx = new TopicCreateTransaction(rest);
    if (transactionMemo) tx.setTransactionMemo(transactionMemo);
    return tx;
  }
  static submitTopicMessage(params) {
    const { transactionMemo, ...rest } = params;
    const tx = new TopicMessageSubmitTransaction(rest);
    if (transactionMemo) tx.setTransactionMemo(transactionMemo);
    return _HederaBuilder.maybeWrapInSchedule(tx, params.schedulingParams);
  }
  static updateTopic(params) {
    return new TopicUpdateTransaction(params);
  }
  static executeTransaction(params) {
    const tx = new ContractExecuteTransaction(params);
    return _HederaBuilder.maybeWrapInSchedule(tx, params.schedulingParams);
  }
  static mintFungibleToken(params) {
    const tx = new TokenMintTransaction(params);
    return _HederaBuilder.maybeWrapInSchedule(tx, params.schedulingParams);
  }
  static mintNonFungibleToken(params) {
    const tx = new TokenMintTransaction(params);
    return _HederaBuilder.maybeWrapInSchedule(tx, params.schedulingParams);
  }
  static dissociateToken(params) {
    return new TokenDissociateTransaction(params);
  }
  static createAccount(params) {
    const tx = new AccountCreateTransaction(params);
    return _HederaBuilder.maybeWrapInSchedule(tx, params.schedulingParams);
  }
  static deleteAccount(params) {
    return new AccountDeleteTransaction(params);
  }
  static updateAccount(params) {
    const tx = new AccountUpdateTransaction(params);
    return _HederaBuilder.maybeWrapInSchedule(tx, params.schedulingParams);
  }
  static deleteToken(params) {
    return new TokenDeleteTransaction(params);
  }
  static deleteTopic(params) {
    return new TopicDeleteTransaction(params);
  }
  static signScheduleTransaction(params) {
    return new ScheduleSignTransaction(params);
  }
  static deleteScheduleTransaction(params) {
    return new ScheduleDeleteTransaction(params);
  }
  static associateToken(params) {
    return new TokenAssociateTransaction({
      accountId: AccountId7.fromString(params.accountId),
      tokenIds: params.tokenIds.map((t) => TokenId4.fromString(t))
    });
  }
  static buildAccountAllowanceApproveTx(params) {
    const tx = new AccountAllowanceApproveTransaction(params);
    if (params.transactionMemo) {
      tx.setTransactionMemo(params.transactionMemo);
    }
    return tx;
  }
  static approveHbarAllowance(params) {
    return this.buildAccountAllowanceApproveTx(params);
  }
  static approveNftAllowance(params) {
    return this.buildAccountAllowanceApproveTx(params);
  }
  static approveTokenAllowance(params) {
    const tx = new AccountAllowanceApproveTransaction(params);
    if (params.transactionMemo) {
      tx.setTransactionMemo(params.transactionMemo);
    }
    return tx;
  }
  static maybeWrapInSchedule(tx, schedulingParams) {
    if (schedulingParams?.isScheduled) {
      return new ScheduleCreateTransaction(schedulingParams).setScheduledTransaction(tx).setWaitForExpiry(schedulingParams.waitForExpiry || false).setExpirationTime(schedulingParams.expirationTime || null);
    }
    return tx;
  }
};

// src/shared/utils/prompt-generator.ts
var PromptGenerator = class {
  /**
   * Generates a consistent context snippet for tool prompts.
   */
  static getContextSnippet(context) {
    const lines = ["Context:"];
    if (context.mode === "returnBytes" /* RETURN_BYTES */) {
      lines.push(`- Mode: Return Bytes (preparing transactions for user signing)`);
      if (context.accountId) {
        lines.push(`- User Account: ${context.accountId} (default for transaction parameters)`);
        lines.push(`- When no account is specified, ${context.accountId} will be used`);
      } else {
        lines.push(`- User Account: Not specified`);
        lines.push(`- When no account is specified, the operator account will be used`);
      }
    } else if (context.mode === "autonomous" /* AUTONOMOUS */) {
      lines.push(`- Mode: Autonomous (agent executes transactions directly)`);
      if (context.accountId) {
        lines.push(`- User Account: ${context.accountId}`);
      }
      lines.push(`- When no account is specified, the operator account will be used`);
    } else {
      lines.push(`- Mode: ${context.mode || "Not specified"}`);
      if (context.accountId) {
        lines.push(`- User Account: ${context.accountId}`);
      }
      lines.push(`- Default account will be determined at execution time`);
    }
    return lines.join("\n");
  }
  static getAnyAddressParameterDescription(paramName, context, isRequired = false) {
    if (isRequired) {
      return `${paramName} (str, required): The account address. This can be the EVM address or the Hedera account id`;
    }
    return `${paramName} (str, optional): The Hedera account ID or EVM address. If not provided, defaults to the ${AccountResolver.getDefaultAccountDescription(context)}`;
  }
  /**
   * Generates a consistent description for optional account parameters.
   */
  static getAccountParameterDescription(paramName, context, isRequired = false) {
    if (isRequired) {
      return `${paramName} (str, required): The Hedera account ID`;
    }
    const defaultAccountDesc = AccountResolver.getDefaultAccountDescription(context);
    return `${paramName} (str, optional): The Hedera account ID. If not provided, defaults to the ${defaultAccountDesc}`;
  }
  /**
   * Generates consistent parameter usage instructions.
   */
  static getParameterUsageInstructions() {
    return `
Important:
- Only include optional parameters if explicitly provided by the user
- Do not generate placeholder values for optional fields
- Leave optional parameters undefined if not specified by the user
- Important: If the user mentions multiple recipients or amounts and tool accepts an array, combine all recipients, tokens or similar assets into a single array and make exactly one call to that tool. Do not split the action into multiple tool calls if it's possible to do so.
`;
  }
  static getScheduledTransactionParamsDescription(context) {
    return `schedulingParams (object, optional): Parameters for scheduling this transaction instead of executing immediately.

**Fields that apply to the *schedule entity*, not the inner transaction:**

- **isScheduled** (boolean, optional, default false):  
  If true, the transaction will be created as a scheduled transaction.  
  If false or omitted, all other scheduling parameters will be ignored.

- **adminKey** (boolean|string, optional, default false):  
  Admin key that can delete or modify the scheduled transaction before execution.  
  - If true, the operator key will be used.  
  - If false or omitted, no admin key is set.  
  - If a string is passed, it will be used as the admin key.

- **payerAccountId** (string, optional):  
  Account that will pay the transaction fee when the scheduled transaction executes.  
  Defaults to the ${AccountResolver.getDefaultAccountDescription(context)}.

- **expirationTime** (string, optional, ISO 8601):  
  Time when the scheduled transaction will expire if not fully signed.

- **waitForExpiry** (boolean, optional, default false):  
  If true, the scheduled transaction will be executed at its expiration time, regardless of when all required signatures are collected.  
  If false, the transaction will execute as soon as all required signatures are present.

**Notes**
- Setting any scheduling parameter implies delayed execution through the Hedera schedule service.
- The network executes the scheduled transaction automatically once all required signatures are collected.
`;
  }
};

// src/plugins/core-token-plugin/tools/fungible-token/airdrop-fungible-token.ts
var airdropFungibleTokenPrompt = (context = {}) => {
  const contextSnippet = PromptGenerator.getContextSnippet(context);
  const sourceAccountDesc = PromptGenerator.getAccountParameterDescription(
    "sourceAccountId",
    context
  );
  const usageInstructions = PromptGenerator.getParameterUsageInstructions();
  return `
${contextSnippet}

This tool will airdrop a fungible token on Hedera.

Parameters:
- tokenId (str, required): The id of the token
- ${sourceAccountDesc}
- recipients (array, required): A list of recipient objects, each containing:
  - accountId (string): The recipient's account ID (e.g., "0.0.1234")
  - amount (number or string): The amount of tokens to send to that recipient (in base units)
- transactionMemo (str, optional): Optional memo for the transaction
${usageInstructions}

If the user specifies multiple recipients in a single request, include them all in **one tool call** as a list of recipients.
`;
};
var postProcess = (response) => {
  return `Token successfully airdropped with transaction id ${response.transactionId.toString()}`;
};
var airdropFungibleToken = async (client, context, params) => {
  try {
    const mirrornodeService = getMirrornodeService(context.mirrornodeService, client.ledgerId);
    const normalisedParams = await HederaParameterNormaliser.normaliseAirdropFungibleTokenParams(
      params,
      context,
      client,
      mirrornodeService
    );
    const tx = HederaBuilder.airdropFungibleToken(normalisedParams);
    const result = await handleTransaction(tx, client, context, postProcess);
    return result;
  } catch (error) {
    const desc = "Failed to airdrop fungible token";
    const message = desc + (error instanceof Error ? `: ${error.message}` : "");
    console.error("[airdrop_fungible_token_tool]", message);
    return { raw: { status: Status.InvalidTransaction, error: message }, humanMessage: message };
  }
};
var AIRDROP_FUNGIBLE_TOKEN_TOOL = "airdrop_fungible_token_tool";
var tool = (context) => ({
  method: AIRDROP_FUNGIBLE_TOKEN_TOOL,
  name: "Airdrop Fungible Token",
  description: airdropFungibleTokenPrompt(context),
  parameters: airdropFungibleTokenParameters(context),
  execute: airdropFungibleToken
});
var airdrop_fungible_token_default = tool;

// src/plugins/core-token-plugin/tools/fungible-token/transfer-fungible-token-with-allowance.ts
import { Status as Status2 } from "@hashgraph/sdk";
var transferFungibleTokenWithAllowancePrompt = (context = {}) => {
  const contextSnippet = PromptGenerator.getContextSnippet(context);
  const usageInstructions = PromptGenerator.getParameterUsageInstructions();
  return `
${contextSnippet}

This tool will transfer a fungible token using an existing **token allowance**.

Parameters:
- tokenId (string, required): The token ID to transfer (e.g. "0.0.12345")
- sourceAccountId (string, required): Account ID of the token owner (the allowance granter)
- transfers (array of objects, required): List of token transfers. Each object should contain:
  - accountId (string): Recipient account ID
  - amount (number): Amount of tokens to transfer in display unit
- transactionMemo (string, optional): Optional memo for the transaction
${PromptGenerator.getScheduledTransactionParamsDescription(context)}

${usageInstructions}

Example: Spend allowance from account 0.0.1002 to send 25 fungible tokens with id 0.0.33333 to 0.0.2002
Example 2: Use allowance from 0.0.1002 to send 50 TKN (FT token id: '0.0.33333') to 0.0.2002 and 75 TKN to 0.0.3003
`;
};
var postProcess2 = (response) => {
  if (response.scheduleId) {
    return `Scheduled allowance transfer created successfully.
Transaction ID: ${response.transactionId}
Schedule ID: ${response.scheduleId.toString()}`;
  }
  return `Fungible tokens successfully transferred with allowance.
Transaction ID: ${response.transactionId}`;
};
var transferFungibleTokenWithAllowance = async (client, context, params) => {
  try {
    const mirrornode = getMirrornodeService(context.mirrornodeService, client.ledgerId);
    const normalisedParams = await HederaParameterNormaliser.normaliseTransferFungibleTokenWithAllowance(
      params,
      context,
      client,
      mirrornode
    );
    const tx = HederaBuilder.transferFungibleTokenWithAllowance(normalisedParams);
    return await handleTransaction(tx, client, context, postProcess2);
  } catch (error) {
    const desc = "Failed to transfer fungible token with allowance";
    const message = desc + (error instanceof Error ? `: ${error.message}` : "");
    console.error("[transfer_fungible_token_with_allowance_tool]", message);
    return { raw: { status: Status2.InvalidTransaction, error: message }, humanMessage: message };
  }
};
var TRANSFER_FUNGIBLE_TOKEN_WITH_ALLOWANCE_TOOL = "transfer_fungible_token_with_allowance_tool";
var tool2 = (context) => ({
  method: TRANSFER_FUNGIBLE_TOKEN_WITH_ALLOWANCE_TOOL,
  name: "Transfer Fungible Token with Allowance",
  description: transferFungibleTokenWithAllowancePrompt(context),
  parameters: transferFungibleTokenWithAllowanceParameters(context),
  execute: transferFungibleTokenWithAllowance
});
var transfer_fungible_token_with_allowance_default = tool2;

// src/plugins/core-token-plugin/tools/fungible-token/create-fungible-token.ts
import { Status as Status3 } from "@hashgraph/sdk";
var createFungibleTokenPrompt = (context = {}) => {
  const contextSnippet = PromptGenerator.getContextSnippet(context);
  const treasuryAccountDesc = PromptGenerator.getAccountParameterDescription(
    "treasuryAccountId",
    context
  );
  const usageInstructions = PromptGenerator.getParameterUsageInstructions();
  return `
${contextSnippet}

This tool creates a fungible token on Hedera.

Parameters:
- tokenName (str, required): The name of the token
- tokenSymbol (str, optional): The symbol of the token
- initialSupply (int, optional): The initial supply of the token, defaults to 0
- supplyType (str, optional): The supply type of the token. Can be "finite" or "infinite". Defaults to "finite"
- maxSupply (int, optional): The maximum supply of the token. Only applicable if supplyType is "finite". Defaults to 1,000,000 if not specified
- decimals (int, optional): The number of decimals the token supports. Defaults to 0
- ${treasuryAccountDesc}
- isSupplyKey (boolean, optional): If user wants to set supply key set to true, otherwise false
${PromptGenerator.getScheduledTransactionParamsDescription(context)}
${usageInstructions}
`;
};
var postProcess3 = (response) => {
  if (response.scheduleId) {
    return `Scheduled transaction created successfully.
Transaction ID: ${response.transactionId}
Schedule ID: ${response.scheduleId.toString()}`;
  }
  const tokenIdStr = response.tokenId ? response.tokenId.toString() : "unknown";
  return `Token created successfully.
Transaction ID: ${response.transactionId}
Token ID: ${tokenIdStr}`;
};
var createFungibleToken = async (client, context, params) => {
  try {
    const mirrornodeService = getMirrornodeService(context.mirrornodeService, client.ledgerId);
    const normalisedParams = await HederaParameterNormaliser.normaliseCreateFungibleTokenParams(
      params,
      context,
      client,
      mirrornodeService
    );
    const tx = HederaBuilder.createFungibleToken(normalisedParams);
    return await handleTransaction(tx, client, context, postProcess3);
  } catch (error) {
    const desc = "Failed to create fungible token";
    const message = desc + (error instanceof Error ? `: ${error.message}` : "");
    console.error("[create_fungible_token_tool]", message);
    return { raw: { status: Status3.InvalidTransaction, error: message }, humanMessage: message };
  }
};
var CREATE_FUNGIBLE_TOKEN_TOOL = "create_fungible_token_tool";
var tool3 = (context) => ({
  method: CREATE_FUNGIBLE_TOKEN_TOOL,
  name: "Create Fungible Token",
  description: createFungibleTokenPrompt(context),
  parameters: createFungibleTokenParameters(context),
  execute: createFungibleToken
});
var create_fungible_token_default = tool3;

// src/plugins/core-token-plugin/tools/fungible-token/mint-fungible-token.ts
import { Status as Status4 } from "@hashgraph/sdk";
var mintFungibleTokenPrompt = (context = {}) => {
  const contextSnippet = PromptGenerator.getContextSnippet(context);
  const usageInstructions = PromptGenerator.getParameterUsageInstructions();
  return `
${contextSnippet}

This tool will mint a given amount (supply) of an existing fungible token on Hedera.

Parameters:
- tokenId (str, required): The id of the token
- amount (number, required): The amount to be minted
${usageInstructions}

Example: "Mint 1 of 0.0.6458037" means minting the amount of 1 of the token with id 0.0.6458037.
`;
};
var postProcess4 = (response) => {
  if (response.scheduleId) {
    return `Scheduled mint transaction created successfully.
Transaction ID: ${response.transactionId.toString()}
Schedule ID: ${response.scheduleId.toString()}`;
  }
  return `Tokens successfully minted.
Transaction ID: ${response.transactionId.toString()}`;
};
var mintFungibleToken = async (client, context, params) => {
  try {
    const mirrornodeService = getMirrornodeService(context.mirrornodeService, client.ledgerId);
    const normalisedParams = await HederaParameterNormaliser.normaliseMintFungibleTokenParams(
      params,
      context,
      client,
      mirrornodeService
    );
    const tx = HederaBuilder.mintFungibleToken(normalisedParams);
    return await handleTransaction(tx, client, context, postProcess4);
  } catch (error) {
    const desc = "Failed to mint fungible token";
    const message = desc + (error instanceof Error ? `: ${error.message}` : "");
    console.error("[mint_fungible_token_tool]", message);
    return { raw: { status: Status4.InvalidTransaction, error: message }, humanMessage: message };
  }
};
var MINT_FUNGIBLE_TOKEN_TOOL = "mint_fungible_token_tool";
var tool4 = (context) => ({
  method: MINT_FUNGIBLE_TOKEN_TOOL,
  name: "Mint Fungible Token",
  description: mintFungibleTokenPrompt(context),
  parameters: mintFungibleTokenParameters(context),
  execute: mintFungibleToken
});
var mint_fungible_token_default = tool4;

// src/plugins/core-token-plugin/tools/non-fungible-token/create-non-fungible-token.ts
import { Status as Status5 } from "@hashgraph/sdk";
var createNonFungibleTokenPrompt = (context = {}) => {
  const contextSnippet = PromptGenerator.getContextSnippet(context);
  const treasuryAccountDesc = PromptGenerator.getAccountParameterDescription(
    "treasuryAccountId",
    context
  );
  const usageInstructions = PromptGenerator.getParameterUsageInstructions();
  return `
${contextSnippet}

This tool creates a non-fungible token (NFT) on Hedera.

Parameters:
- tokenName (str, required): Name of the token
- tokenSymbol (str, required): Symbol of the token
- maxSupply (int, optional): Maximum NFT supply. Defaults to 100 if not provided
- ${treasuryAccountDesc}
${PromptGenerator.getScheduledTransactionParamsDescription(context)}

${usageInstructions}
`;
};
var postProcess5 = (response) => {
  if (response.scheduleId) {
    return `Scheduled transaction created successfully.
Transaction ID: ${response.transactionId.toString()}
Schedule ID: ${response.scheduleId.toString()}`;
  }
  const tokenIdStr = response.tokenId ? response.tokenId.toString() : "unknown";
  return `Token created successfully.
Transaction ID: ${response.transactionId.toString()}
Token ID: ${tokenIdStr}`;
};
var createNonFungibleToken = async (client, context, params) => {
  try {
    const mirrornodeService = getMirrornodeService(context.mirrornodeService, client.ledgerId);
    const normalisedParams = await HederaParameterNormaliser.normaliseCreateNonFungibleTokenParams(
      params,
      context,
      client,
      mirrornodeService
    );
    const tx = HederaBuilder.createNonFungibleToken(normalisedParams);
    return await handleTransaction(tx, client, context, postProcess5);
  } catch (error) {
    const desc = "Failed to create non-fungible token";
    const message = desc + (error instanceof Error ? `: ${error.message}` : "");
    console.error("[create_non_fungible_token_tool]", message);
    return { raw: { status: Status5.InvalidTransaction, error: message }, humanMessage: message };
  }
};
var CREATE_NON_FUNGIBLE_TOKEN_TOOL = "create_non_fungible_token_tool";
var tool5 = (context) => ({
  method: CREATE_NON_FUNGIBLE_TOKEN_TOOL,
  name: "Create Non-Fungible Token",
  description: createNonFungibleTokenPrompt(context),
  parameters: createNonFungibleTokenParameters(context),
  execute: createNonFungibleToken
});
var create_non_fungible_token_default = tool5;

// src/plugins/core-token-plugin/tools/non-fungible-token/mint-non-fungible-token.ts
import { Status as Status6 } from "@hashgraph/sdk";
var mintNonFungibleTokenPrompt = (_context = {}) => {
  const usageInstructions = PromptGenerator.getParameterUsageInstructions();
  return `

This tool will mint NFTs with its unique metadata for the class of NFTs (non-fungible tokens) defined by the tokenId on Hedera.

Parameters:
- tokenId (str, required): The id of the token
- uris (array, required): An array of strings (URIs) of maximum size 10 hosting the NFT metadata
${usageInstructions}

Example: "Mint 0.0.6465503 with metadata: ipfs://bafyreiao6ajgsfji6qsgbqwdtjdu5gmul7tv2v3pd6kjgcw5o65b2ogst4/metadata.json" means minting an NFT with the given metadata URI for the class of NFTs defined by the token with id 0.0.6465503.
`;
};
var postProcess6 = (response) => {
  if (response.scheduleId) {
    return `Scheduled mint transaction created successfully.
Transaction ID: ${response.transactionId.toString()}
Schedule ID: ${response.scheduleId.toString()}`;
  }
  const tokenIdStr = response.tokenId ? response.tokenId.toString() : "unknown";
  return `Token successfully minted.
Transaction ID: ${response.transactionId.toString()}
Token ID: ${tokenIdStr}`;
};
var mintNonFungibleToken = async (client, context, params) => {
  try {
    const normalisedParams = await HederaParameterNormaliser.normaliseMintNonFungibleTokenParams(
      params,
      context,
      client
    );
    const tx = HederaBuilder.mintNonFungibleToken(normalisedParams);
    return await handleTransaction(tx, client, context, postProcess6);
  } catch (error) {
    const desc = "Failed to mint non-fungible token";
    const message = desc + (error instanceof Error ? `: ${error.message}` : "");
    console.error("[mint_non_fungible_token_tool]", message);
    return { raw: { status: Status6.InvalidTransaction, error: message }, humanMessage: message };
  }
};
var MINT_NON_FUNGIBLE_TOKEN_TOOL = "mint_non_fungible_token_tool";
var tool6 = (context) => ({
  method: MINT_NON_FUNGIBLE_TOKEN_TOOL,
  name: "Mint Non-Fungible Token",
  description: mintNonFungibleTokenPrompt(context),
  parameters: mintNonFungibleTokenParameters(context),
  execute: mintNonFungibleToken
});
var mint_non_fungible_token_default = tool6;

// src/plugins/core-token-plugin/tools/non-fungible-token/approve-non-fungible-token-allowance.ts
import { Status as Status7 } from "@hashgraph/sdk";
var approveNftAllowancePrompt = (context = {}) => {
  const contextSnippet = PromptGenerator.getContextSnippet(context);
  const ownerAccountDesc = PromptGenerator.getAccountParameterDescription(
    "ownerAccountId",
    context
  );
  const usageInstructions = PromptGenerator.getParameterUsageInstructions();
  return `
${contextSnippet}

This tool approves an NFT allowance from the owner to the spender for specific NFT serial numbers of a token, or for all serials in the NFT collection.

Parameters:
- ${ownerAccountDesc}
- spenderAccountId (string, required): Spender account ID
- tokenId (string, required): The NFT token ID (e.g., 0.0.xxxxx)
- allSerials (boolean, optional): If true, approves allowance for all current and future serials of the NFT. When true, do not provide serialNumbers.
- serialNumbers (number[], conditionally required): Array of NFT serial numbers to approve. Required when allSerials is not true.
- transactionMemo (string, optional): Optional memo for the transaction
${usageInstructions}
`;
};
var postProcess7 = (response) => {
  return `NFT allowance approved successfully. Transaction ID: ${response.transactionId}`;
};
var approveNftAllowance = async (client, context, params) => {
  try {
    const normalisedParams = HederaParameterNormaliser.normaliseApproveNftAllowance(
      params,
      context,
      client
    );
    const tx = HederaBuilder.approveNftAllowance(normalisedParams);
    return await handleTransaction(tx, client, context, postProcess7);
  } catch (error) {
    const desc = "Failed to Approve NFT allowance";
    const message = desc + (error instanceof Error ? `: ${error.message}` : "");
    console.error("[approve_nft_allowance_tool]", message);
    return { raw: { status: Status7.InvalidTransaction, error: message }, humanMessage: message };
  }
};
var APPROVE_NFT_ALLOWANCE_TOOL = "approve_nft_allowance_tool";
var tool7 = (context) => ({
  method: APPROVE_NFT_ALLOWANCE_TOOL,
  name: "Approve NFT Allowance",
  description: approveNftAllowancePrompt(context),
  parameters: approveNftAllowanceParameters(context).innerType(),
  execute: approveNftAllowance
});
var approve_non_fungible_token_allowance_default = tool7;

// src/plugins/core-token-plugin/tools/update-token.ts
import { PublicKey as PublicKey6, Status as Status8 } from "@hashgraph/sdk";
var checkValidityOfUpdates = async (params, mirrornode, userPublicKey) => {
  const tokenDetails = await mirrornode.getTokenInfo(params.tokenId.toString());
  if (!tokenDetails) {
    throw new Error("Token not found");
  }
  if (tokenDetails.admin_key?.key !== userPublicKey.toStringRaw()) {
    console.error(
      `tokenDetails.admin_key.key: ${tokenDetails.admin_key?.key} vs userPublicKey: ${userPublicKey.toStringRaw()}`
    );
    throw new Error(
      "You do not have permission to update this token. The adminKey does not match your public key."
    );
  }
  const keyChecks = {
    adminKey: "admin_key",
    kycKey: "kyc_key",
    freezeKey: "freeze_key",
    wipeKey: "wipe_key",
    supplyKey: "supply_key",
    feeScheduleKey: "fee_schedule_key",
    pauseKey: "pause_key",
    metadataKey: "metadata_key"
  };
  for (const [paramKey, tokenField] of Object.entries(keyChecks)) {
    const userValue = params[paramKey];
    const tokenKey = tokenDetails[tokenField];
    if (userValue instanceof PublicKey6 && !tokenKey) {
      throw new Error(`Cannot update ${paramKey}: token was created without a ${paramKey}`);
    }
  }
};
var updateTokenPrompt = (context = {}) => {
  const contextSnippet = PromptGenerator.getContextSnippet(context);
  const tokenDesc = PromptGenerator.getAnyAddressParameterDescription("tokenId", context);
  const usageInstructions = PromptGenerator.getParameterUsageInstructions();
  return `
${contextSnippet}

This tool will update an existing Hedera HTS token. Only the fields provided will be updated.

Key fields (adminKey, kycKey, freezeKey, wipeKey, supplyKey, feeScheduleKey, pauseKey, metadataKey) must contain **Hedera-compatible public keys (as strings) or boolean (true/false)**. You can provide these in one of three ways:

1. **Boolean true** \u2013 Set this field to use user/operator key. Injecting of the key will be handled automatically.
2. **Not provided** \u2013 The field will not be updated.
3. **String** \u2013 Provide a Hedera-compatible public key string to set a field explicitly.

Parameters:
- ${tokenDesc}
- tokenName (string, optional): New name for the token. Up to 100 characters.
- tokenSymbol (string, optional): New symbol for the token. Up to 100 characters.
- treasuryAccountId (string, optional): New treasury account for the token (Hedera account ID).
- adminKey (boolean|string, optional): New admin key. Pass true to use your operator key, or provide a public key string.
- kycKey (boolean|string, optional): New KYC key. Pass true to use your operator key, or provide a public key string.
- freezeKey (boolean|string, optional): New freeze key. Pass true to use your operator key, or provide a public key string.
- wipeKey (boolean|string, optional): New wipe key. Pass true to use your operator key, or provide a public key string.
- supplyKey (boolean|string, optional): New supply key. Pass true to use your operator key, or provide a public key string.
- feeScheduleKey (boolean|string, optional): New fee schedule key. Pass true to use your operator key, or provide a public key string.
- pauseKey (boolean|string, optional): New pause key. Pass true to use your operator key, or provide a public key string.
- metadataKey (boolean|string, optional): New metadata key. Pass true to use your operator key, or provide a public key string.
- metadata (string, optional): New metadata for the token, in bytes (hex or base64).
- tokenMemo (string, optional): Short public memo for the token, up to 100 characters.
- autoRenewAccountId (string, optional): Account to automatically pay for renewal.

Examples:
- If the user asks for "my key" \u2192 set the field to \`true\`.
- If the user does not mention the key \u2192 do not set the field.
- If the user provides a key \u2192 set the field to the provided public key string.

If the user provides multiple fields in a single request, 
combine them into **one tool call** with all parameters together.

${usageInstructions}
`;
};
var postProcess8 = (response) => {
  return `Token successfully updated. Transaction ID: ${response.transactionId}`;
};
var updateToken = async (client, context, params) => {
  try {
    const normalisedParams = await HederaParameterNormaliser.normaliseUpdateToken(
      params,
      context,
      client
    );
    const mirrornodeService = getMirrornodeService(context.mirrornodeService, client.ledgerId);
    const userPublicKey = await AccountResolver.getDefaultPublicKey(context, client);
    await checkValidityOfUpdates(normalisedParams, mirrornodeService, userPublicKey);
    const tx = HederaBuilder.updateToken(normalisedParams);
    return await handleTransaction(tx, client, context, postProcess8);
  } catch (error) {
    const desc = "Failed to update token";
    const message = desc + (error instanceof Error ? `: ${error.message}` : "");
    console.error("[update_token_tool]", message);
    return {
      raw: { status: Status8.InvalidTransaction, error: message },
      humanMessage: message
    };
  }
};
var UPDATE_TOKEN_TOOL = "update_token_tool";
var tool8 = (context) => ({
  method: UPDATE_TOKEN_TOOL,
  name: "Update Token",
  description: updateTokenPrompt(context),
  parameters: updateTokenParameters(context),
  execute: updateToken
});
var update_token_default = tool8;

// src/plugins/core-token-plugin/tools/dissociate-token.ts
import { Status as Status9 } from "@hashgraph/sdk";
var dissociateTokenPrompt = (context = {}) => {
  const contextSnippet = PromptGenerator.getContextSnippet(context);
  const sourceAccountDesc = PromptGenerator.getAccountParameterDescription("accountId", context);
  const usageInstructions = PromptGenerator.getParameterUsageInstructions();
  return `
${contextSnippet}

This tool will airdrop a fungible token on Hedera.

Parameters:
- tokenIds (array of strings, required): A list of Hedera token IDs to dissociate from the account. Example: ["0.0.1234", "0.0.5678"]
- ${sourceAccountDesc}, account from which to dissociate the token(s)
- transactionMemo (str, optional): Optional memo for the transaction

Examples:
- Dissociate a single token: { "tokenIds": ["0.0.1234"] }
- Dissociate multiple tokens from a specific account: { "tokenIds": ["0.0.1234", "0.0.5678"], "accountId": "0.0.4321" }

${usageInstructions}
`;
};
var postProcess9 = (response) => {
  return `Token(s) successfully dissociated with transaction id ${response.transactionId.toString()}`;
};
var dissociateToken = async (client, context, params) => {
  try {
    const normalisedParams = await HederaParameterNormaliser.normaliseDissociateTokenParams(
      params,
      context,
      client
    );
    const tx = HederaBuilder.dissociateToken(normalisedParams);
    return await handleTransaction(tx, client, context, postProcess9);
  } catch (error) {
    const desc = "Failed to dissociate token";
    const message = desc + (error instanceof Error ? `: ${error.message}` : "");
    console.error("[dissociate_token_tool]", message);
    return { raw: { status: Status9.InvalidTransaction, error: message }, humanMessage: message };
  }
};
var DISSOCIATE_TOKEN_TOOL = "dissociate_token_tool";
var tool9 = (context) => ({
  method: DISSOCIATE_TOKEN_TOOL,
  name: "Dissociate Token",
  description: dissociateTokenPrompt(context),
  parameters: dissociateTokenParameters(context),
  execute: dissociateToken
});
var dissociate_token_default = tool9;

// src/plugins/core-token-plugin/tools/associate-token.ts
import { Status as Status10 } from "@hashgraph/sdk";
var associateTokenPrompt = (context = {}) => {
  const contextSnippet = PromptGenerator.getContextSnippet(context);
  const usageInstructions = PromptGenerator.getParameterUsageInstructions();
  const accountToAssociate = PromptGenerator.getAnyAddressParameterDescription("accountId", context);
  return `
${contextSnippet}

This tool will associate one or more tokens with a Hedera account.

Parameters:
${accountToAssociate}
- tokenIds (string[], required): Array of token IDs to associate
${usageInstructions}

Example: "Associate tokens 0.0.123 and 0.0.456 to account 0.0.789".
`;
};
var postProcess10 = (response) => {
  return `Tokens successfully associated with transaction id ${response.transactionId.toString()}`;
};
var associateToken = async (client, context, params) => {
  try {
    const normalisedParams = HederaParameterNormaliser.normaliseAssociateTokenParams(
      params,
      context,
      client
    );
    const tx = HederaBuilder.associateToken(normalisedParams);
    const result = await handleTransaction(tx, client, context, postProcess10);
    return result;
  } catch (error) {
    const desc = "Failed to associate token(s)";
    const message = desc + (error instanceof Error ? `: ${error.message}` : "");
    console.error("[associate_token_tool]", message);
    return { raw: { status: Status10.InvalidTransaction, error: message }, humanMessage: message };
  }
};
var ASSOCIATE_TOKEN_TOOL = "associate_token_tool";
var tool10 = (context) => ({
  method: ASSOCIATE_TOKEN_TOOL,
  name: "Associate Token(s)",
  description: associateTokenPrompt(context),
  parameters: associateTokenParameters(context),
  execute: associateToken
});
var associate_token_default = tool10;

// src/plugins/core-token-plugin/tools/non-fungible-token/transfer-non-fungible-token-with-allowance.ts
import { Status as Status11 } from "@hashgraph/sdk";
var transferNonFungibleTokenWithAllowancePrompt = (context = {}) => {
  const contextSnippet = PromptGenerator.getContextSnippet(context);
  const usageInstructions = PromptGenerator.getParameterUsageInstructions();
  return `
${contextSnippet}
This tool will transfer non-fungible tokens (NFTs) using an existing **token allowance**.

Parameters:
- sourceAccountId (string, required): The token owner (allowance granter)
- tokenId (string, required): The NFT token ID to transfer (e.g. "0.0.12345")
- recipients (array, required): List of objects specifying recipients and serial numbers
  - recipientId (string): Account to transfer to
  - serialNumber (string): NFT serial number to transfer
- transactionMemo (string, optional): Optional memo for the transaction

${usageInstructions}
`;
};
var postProcess11 = (response) => {
  return `Non-fungible tokens successfully transferred with allowance. Transaction ID: ${response.transactionId}`;
};
var transferNonFungibleTokenWithAllowance = async (client, context, params) => {
  try {
    const normalisedParams = HederaParameterNormaliser.normaliseTransferNonFungibleTokenWithAllowance(params, context);
    const tx = HederaBuilder.transferNonFungibleTokenWithAllowance(normalisedParams);
    return await handleTransaction(tx, client, context, postProcess11);
  } catch (error) {
    const desc = "Failed to transfer non-fungible token with allowance";
    const message = desc + (error instanceof Error ? `: ${error.message}` : "");
    console.error("[transfer_non_fungible_token_with_allowance_tool]", message);
    return { raw: { status: Status11.InvalidTransaction, error: message }, humanMessage: message };
  }
};
var TRANSFER_NON_FUNGIBLE_TOKEN_WITH_ALLOWANCE_TOOL = "transfer_non_fungible_token_with_allowance_tool";
var tool11 = (context) => ({
  method: TRANSFER_NON_FUNGIBLE_TOKEN_WITH_ALLOWANCE_TOOL,
  name: "Transfer Non Fungible Token with Allowance",
  description: transferNonFungibleTokenWithAllowancePrompt(context),
  parameters: transferNonFungibleTokenWithAllowanceParameters(context).innerType(),
  execute: transferNonFungibleTokenWithAllowance
});
var transfer_non_fungible_token_with_allowance_default = tool11;

// src/plugins/core-token-plugin/index.ts
var coreTokenPlugin = {
  name: "core-token-plugin",
  version: "1.0.0",
  description: "A plugin for the Hedera Token Service",
  tools: (context) => {
    return [
      create_fungible_token_default(context),
      mint_fungible_token_default(context),
      create_non_fungible_token_default(context),
      airdrop_fungible_token_default(context),
      mint_non_fungible_token_default(context),
      approve_non_fungible_token_allowance_default(context),
      update_token_default(context),
      dissociate_token_default(context),
      associate_token_default(context),
      transfer_non_fungible_token_with_allowance_default(context),
      transfer_fungible_token_with_allowance_default(context)
    ];
  }
};
var coreTokenPluginToolNames = {
  AIRDROP_FUNGIBLE_TOKEN_TOOL,
  CREATE_FUNGIBLE_TOKEN_TOOL,
  MINT_FUNGIBLE_TOKEN_TOOL,
  CREATE_NON_FUNGIBLE_TOKEN_TOOL,
  MINT_NON_FUNGIBLE_TOKEN_TOOL,
  APPROVE_NFT_ALLOWANCE_TOOL,
  DISSOCIATE_TOKEN_TOOL,
  ASSOCIATE_TOKEN_TOOL,
  UPDATE_TOKEN_TOOL,
  TRANSFER_NON_FUNGIBLE_TOKEN_WITH_ALLOWANCE_TOOL,
  TRANSFER_FUNGIBLE_TOKEN_WITH_ALLOWANCE_TOOL
};

// src/plugins/core-account-plugin/tools/account/transfer-hbar.ts
import { Status as Status12 } from "@hashgraph/sdk";
var transferHbarPrompt = (context = {}) => {
  const contextSnippet = PromptGenerator.getContextSnippet(context);
  const sourceAccountDesc = PromptGenerator.getAccountParameterDescription(
    "sourceAccountId",
    context
  );
  const usageInstructions = PromptGenerator.getParameterUsageInstructions();
  return `
${contextSnippet}

This tool will transfer HBAR to an account.

Parameters:
- transfers (array of objects, required): List of HBAR transfers. Each object should contain:
  - accountId (string): Recipient account ID
  - amount (number): Amount of HBAR to transfer
- ${sourceAccountDesc}
- transactionMemo (string, optional): Optional memo for the transfer HBAR transaction
${PromptGenerator.getScheduledTransactionParamsDescription(context)}

${usageInstructions}
`;
};
var postProcess12 = (response) => {
  if (response.scheduleId) {
    return `Scheduled HBAR transfer created successfully.
Transaction ID: ${response.transactionId}
Schedule ID: ${response.scheduleId.toString()}`;
  }
  return `HBAR successfully transferred.
Transaction ID: ${response.transactionId}`;
};
var transferHbar = async (client, context, params) => {
  try {
    const normalisedParams = await HederaParameterNormaliser.normaliseTransferHbar(
      params,
      context,
      client
    );
    const tx = HederaBuilder.transferHbar(normalisedParams);
    return await handleTransaction(tx, client, context, postProcess12);
  } catch (error) {
    const desc = "Failed to transfer HBAR";
    const message = desc + (error instanceof Error ? `: ${error.message}` : "");
    console.error("[transfer_hbar_tool]", message);
    return { raw: { status: Status12.InvalidTransaction, error: message }, humanMessage: message };
  }
};
var TRANSFER_HBAR_TOOL = "transfer_hbar_tool";
var tool12 = (context) => ({
  method: TRANSFER_HBAR_TOOL,
  name: "Transfer HBAR",
  description: transferHbarPrompt(context),
  parameters: transferHbarParameters(context),
  execute: transferHbar
});
var transfer_hbar_default = tool12;

// src/plugins/core-account-plugin/tools/account/transfer-hbar-with-allowance.ts
import { Status as Status13 } from "@hashgraph/sdk";
var transferHbarWithAllowancePrompt = (context = {}) => {
  const contextSnippet = PromptGenerator.getContextSnippet(context);
  const usageInstructions = PromptGenerator.getParameterUsageInstructions();
  return `
${contextSnippet}

This tool will transfer HBAR using an existing allowance.

Parameters:
- sourceAccountId (string, required): Account ID of the HBAR owner (the allowance granter)
- transfers (array of objects, required): List of HBAR transfers. Each object should contain:
  - accountId (string): Recipient account ID
  - amount (number): Amount of HBAR to transfer
- transactionMemo (string, optional): Optional memo for the transfer HBAR with allowance transaction
${usageInstructions}
`;
};
var postProcess13 = (response) => {
  return `HBAR successfully transferred with allowance. Transaction ID: ${response.transactionId}`;
};
var transferHbarWithAllowance = async (client, context, params) => {
  try {
    const normalisedParams = HederaParameterNormaliser.normaliseTransferHbarWithAllowance(
      params,
      context,
      client
    );
    const tx = HederaBuilder.transferHbarWithAllowance(normalisedParams);
    return await handleTransaction(tx, client, context, postProcess13);
  } catch (error) {
    const desc = "Failed to transfer HBAR with allowance";
    const message = desc + (error instanceof Error ? `: ${error.message}` : "");
    console.error("[transfer_hbar_with_allowance_tool]", message);
    return { raw: { status: Status13.InvalidTransaction, error: message }, humanMessage: message };
  }
};
var TRANSFER_HBAR_WITH_ALLOWANCE_TOOL = "transfer_hbar_with_allowance_tool";
var tool13 = (context) => ({
  method: TRANSFER_HBAR_WITH_ALLOWANCE_TOOL,
  name: "Transfer HBAR with allowance",
  description: transferHbarWithAllowancePrompt(context),
  parameters: transferHbarWithAllowanceParameters(context),
  execute: transferHbarWithAllowance
});
var transfer_hbar_with_allowance_default = tool13;

// src/plugins/core-account-plugin/tools/account/approve-hbar-allowance.ts
import { Status as Status14 } from "@hashgraph/sdk";
var approveHbarAllowancePrompt = (context = {}) => {
  const contextSnippet = PromptGenerator.getContextSnippet(context);
  const ownerAccountDesc = PromptGenerator.getAccountParameterDescription(
    "ownerAccountId",
    context
  );
  const usageInstructions = PromptGenerator.getParameterUsageInstructions();
  return `
${contextSnippet}

This tool approves an HBAR allowance from the owner to the spender.

Parameters:
- ${ownerAccountDesc}
- spenderAccountId (string, required): Spender account ID
- amount (number, required): Amount of HBAR to approve (can be decimal, cannot be negative)
- transactionMemo (string, optional): Optional memo for the transaction
${usageInstructions}
`;
};
var postProcess14 = (response) => {
  return `HBAR allowance approved successfully. Transaction ID: ${response.transactionId}`;
};
var approveHbarAllowance = async (client, context, params) => {
  try {
    const normalisedParams = HederaParameterNormaliser.normaliseApproveHbarAllowance(
      params,
      context,
      client
    );
    const tx = HederaBuilder.approveHbarAllowance(normalisedParams);
    return await handleTransaction(tx, client, context, postProcess14);
  } catch (error) {
    const desc = "Failed to approve hbar allowance.";
    const message = desc + (error instanceof Error ? `: ${error.message}` : "");
    console.error("[approve_hbar_allowance_tool]", message);
    return { raw: { status: Status14.InvalidTransaction, error: message }, humanMessage: message };
  }
};
var APPROVE_HBAR_ALLOWANCE_TOOL = "approve_hbar_allowance_tool";
var tool14 = (context) => ({
  method: APPROVE_HBAR_ALLOWANCE_TOOL,
  name: "Approve HBAR Allowance",
  description: approveHbarAllowancePrompt(context),
  parameters: approveHbarAllowanceParameters(context),
  execute: approveHbarAllowance
});
var approve_hbar_allowance_default = tool14;

// src/plugins/core-account-plugin/tools/account/create-account.ts
import { Status as Status15 } from "@hashgraph/sdk";
var createAccountPrompt = (context = {}) => {
  const contextSnippet = PromptGenerator.getContextSnippet(context);
  const usageInstructions = PromptGenerator.getParameterUsageInstructions();
  return `
${contextSnippet}

This tool will create a new Hedera account with a passed public key. If not passed, the tool will use operators public key.

Parameters:
- publicKey (string, optional): Public key to use for the account. If not provided, the tool will use the operators public key.
- accountMemo (string, optional): Optional memo for the account
- initialBalance (number, optional, default 0): Initial HBAR to fund the account
- maxAutomaticTokenAssociations (number, optional, default -1): -1 means unlimited
- ${PromptGenerator.getScheduledTransactionParamsDescription(context)}

${usageInstructions}
`;
};
var postProcess15 = (response) => {
  if (response.scheduleId) {
    return `Scheduled transaction created successfully.
Transaction ID: ${response.transactionId}
Schedule ID: ${response.scheduleId.toString()}
}`;
  }
  const accountIdStr = response.accountId ? response.accountId.toString() : "unknown";
  return `Account created successfully.
Transaction ID: ${response.transactionId}
New Account ID: ${accountIdStr}
}`;
};
var createAccount = async (client, context, params) => {
  try {
    const mirrornodeService = getMirrornodeService(context.mirrornodeService, client.ledgerId);
    const normalisedParams = await HederaParameterNormaliser.normaliseCreateAccount(
      params,
      context,
      client,
      mirrornodeService
    );
    const tx = HederaBuilder.createAccount(normalisedParams);
    return await handleTransaction(tx, client, context, postProcess15);
  } catch (error) {
    const desc = "Failed to create account";
    const message = desc + (error instanceof Error ? `: ${error.message}` : "");
    console.error("[create_account_tool]", message);
    return { raw: { status: Status15.InvalidTransaction, error: message }, humanMessage: message };
  }
};
var CREATE_ACCOUNT_TOOL = "create_account_tool";
var tool15 = (context) => ({
  method: CREATE_ACCOUNT_TOOL,
  name: "Create Account",
  description: createAccountPrompt(context),
  parameters: createAccountParameters(context),
  execute: createAccount
});
var create_account_default = tool15;

// src/plugins/core-account-plugin/tools/account/delete-account.ts
import { Status as Status16 } from "@hashgraph/sdk";
var deleteAccountPrompt = (context = {}) => {
  const contextSnippet = PromptGenerator.getContextSnippet(context);
  const accountDesc = PromptGenerator.getAccountParameterDescription("accountId", context);
  const usageInstructions = PromptGenerator.getParameterUsageInstructions();
  return `
${contextSnippet}

This tool will delete an existing Hedera account. The remaining balance of the account will be transferred to the transferAccountId if provided, otherwise the operator account will be used.

Parameters:
- ${accountDesc}
- accountId (str, required): The account ID to delete
- transferAccountId (str, optional): The account ID to transfer the remaining balance to. If not provided, the operator account will be used.
${usageInstructions}
`;
};
var postProcess16 = (response) => {
  return `Account successfully deleted. Transaction ID: ${response.transactionId}`;
};
var deleteAccount = async (client, context, params) => {
  try {
    const normalisedParams = HederaParameterNormaliser.normaliseDeleteAccount(
      params,
      context,
      client
    );
    let tx = HederaBuilder.deleteAccount(normalisedParams);
    const result = await handleTransaction(tx, client, context, postProcess16);
    return result;
  } catch (error) {
    const desc = "Failed to delete account";
    const message = desc + (error instanceof Error ? `: ${error.message}` : "");
    console.error("[delete_account_tool]", message);
    return { raw: { status: Status16.InvalidTransaction, error: message }, humanMessage: message };
  }
};
var DELETE_ACCOUNT_TOOL = "delete_account_tool";
var tool16 = (context) => ({
  method: DELETE_ACCOUNT_TOOL,
  name: "Delete Account",
  description: deleteAccountPrompt(context),
  parameters: deleteAccountParameters(context),
  execute: deleteAccount
});
var delete_account_default = tool16;

// src/plugins/core-account-plugin/tools/account/update-account.ts
import { Status as Status17 } from "@hashgraph/sdk";
var updateAccountPrompt = (context = {}) => {
  const contextSnippet = PromptGenerator.getContextSnippet(context);
  const accountDesc = PromptGenerator.getAccountParameterDescription("accountId", context);
  const usageInstructions = PromptGenerator.getParameterUsageInstructions();
  return `
${contextSnippet}

This tool will update an existing Hedera account. Only provided fields will be updated.

Parameters:
- ${accountDesc}
- accountId (string, optional) Account ID to update (e.g., 0.0.xxxxx). If not provided, operator account ID will be used
- maxAutomaticTokenAssociations (number, optional)
- stakedAccountId (string, optional)
- accountMemo (string, optional) - memo to be set for the upgraded account
- declineStakingReward (boolean, optional)
- ${PromptGenerator.getScheduledTransactionParamsDescription(context)}

${usageInstructions}
`;
};
var postProcess17 = (response) => {
  if (response.scheduleId) {
    return `Scheduled account update created successfully.
Transaction ID: ${response.transactionId}
Schedule ID: ${response.scheduleId.toString()}`;
  }
  return `Account successfully updated.
Transaction ID: ${response.transactionId}`;
};
var updateAccount = async (client, context, params) => {
  try {
    const normalisedParams = await HederaParameterNormaliser.normaliseUpdateAccount(
      params,
      context,
      client
    );
    const tx = HederaBuilder.updateAccount(normalisedParams);
    return await handleTransaction(tx, client, context, postProcess17);
  } catch (error) {
    const desc = "Failed to update account";
    const message = desc + (error instanceof Error ? `: ${error.message}` : "");
    console.error("[update_account_tool]", message);
    return { raw: { status: Status17.InvalidTransaction, error: message }, humanMessage: message };
  }
};
var UPDATE_ACCOUNT_TOOL = "update_account_tool";
var tool17 = (context) => ({
  method: UPDATE_ACCOUNT_TOOL,
  name: "Update Account",
  description: updateAccountPrompt(context),
  parameters: updateAccountParameters(context),
  execute: updateAccount
});
var update_account_default = tool17;

// src/plugins/core-account-plugin/tools/account/sign-schedule-transaction.ts
import { Status as Status18 } from "@hashgraph/sdk";
var signScheduleTransactionPrompt = (context = {}) => {
  const contextSnippet = PromptGenerator.getContextSnippet(context);
  const usageInstructions = PromptGenerator.getParameterUsageInstructions();
  return `
${contextSnippet}

This tool will sign a scheduled transaction and return the transaction ID.

Parameters:
- scheduleId (string, required): The ID of the scheduled transaction to sign
${usageInstructions}
`;
};
var postProcess18 = (response) => {
  return `Transaction successfully signed. Transaction ID: ${response.transactionId}`;
};
var signScheduleTransaction = async (client, context, params) => {
  try {
    const tx = HederaBuilder.signScheduleTransaction(params);
    const result = await handleTransaction(tx, client, context, postProcess18);
    return result;
  } catch (error) {
    const desc = "Failed to sign scheduled transaction";
    const message = desc + (error instanceof Error ? `: ${error.message}` : "");
    console.error("[sign_schedule_transaction_tool]", message);
    return { raw: { status: Status18.InvalidTransaction, error: message }, humanMessage: message };
  }
};
var SIGN_SCHEDULE_TRANSACTION_TOOL = "sign_schedule_transaction_tool";
var tool18 = (context) => ({
  method: SIGN_SCHEDULE_TRANSACTION_TOOL,
  name: "Sign Scheduled Transaction",
  description: signScheduleTransactionPrompt(context),
  parameters: signScheduleTransactionParameters(context),
  execute: signScheduleTransaction
});
var sign_schedule_transaction_default = tool18;

// src/plugins/core-account-plugin/tools/account/schedule-delete.ts
import { Status as Status19 } from "@hashgraph/sdk";
var scheduleDeletePrompt = (context = {}) => {
  const contextSnippet = PromptGenerator.getContextSnippet(context);
  const usageInstructions = PromptGenerator.getParameterUsageInstructions();
  return `
${contextSnippet}

This tool will delete a scheduled transaction (by admin) so it will not execute.

Parameters:
- scheduleId (string, required): The ID of the scheduled transaction to delete
${usageInstructions}
`;
};
var postProcess19 = (response) => {
  return `Scheduled transaction successfully deleted. Transaction ID: ${response.transactionId}`;
};
var scheduleDelete = async (client, context, params) => {
  try {
    const tx = HederaBuilder.deleteScheduleTransaction(params);
    const result = await handleTransaction(tx, client, context, postProcess19);
    return result;
  } catch (error) {
    const desc = "Failed to delete scheduled transaction";
    const message = desc + (error instanceof Error ? `: ${error.message}` : "");
    console.error("[schedule_delete_tool]", message);
    return { raw: { status: Status19.InvalidTransaction, error: message }, humanMessage: message };
  }
};
var SCHEDULE_DELETE_TOOL = "schedule_delete_tool";
var tool19 = (context) => ({
  method: SCHEDULE_DELETE_TOOL,
  name: "Delete Scheduled Transaction",
  description: scheduleDeletePrompt(context),
  parameters: scheduleDeleteTransactionParameters(context),
  execute: scheduleDelete
});
var schedule_delete_default = tool19;

// src/plugins/core-account-plugin/tools/account/delete-hbar-allowance.ts
import { Status as Status20 } from "@hashgraph/sdk";
var deleteHbarAllowancePrompt = (context = {}) => {
  const contextSnippet = PromptGenerator.getContextSnippet(context);
  const ownerAccountDesc = PromptGenerator.getAccountParameterDescription(
    "ownerAccountId",
    context
  );
  const usageInstructions = PromptGenerator.getParameterUsageInstructions();
  return `
${contextSnippet}

This tool deletes an HBAR allowance from the owner to the spender.

Parameters:
- ${ownerAccountDesc}
- spenderAccountId (string, required): Spender account ID
- transactionMemo (string, optional): Optional memo for the transaction
${usageInstructions}

Example: "Delete HBAR allowance from 0.0.123 to 0.0.456". Spender account ID is 0.0.456 and the owner account ID is 0.0.789.
Example 2: "Delete HBAR allowance for 0.0.123". Spender account ID is 0.0.123 and the owner account ID was not specified.
`;
};
var postProcess20 = (response) => {
  return `HBAR allowance deleted successfully. Transaction ID: ${response.transactionId}`;
};
var deleteHbarAllowance = async (client, context, params) => {
  try {
    const normalisedParams = HederaParameterNormaliser.normaliseDeleteHbarAllowance(
      params,
      context,
      client
    );
    const tx = HederaBuilder.approveHbarAllowance(normalisedParams);
    return await handleTransaction(tx, client, context, postProcess20);
  } catch (error) {
    const desc = "Failed to delete hbar allowance.";
    const message = desc + (error instanceof Error ? `: ${error.message}` : "");
    console.error("[delete_hbar_allowance_tool]", message);
    return { raw: { status: Status20.InvalidTransaction, error: message }, humanMessage: message };
  }
};
var DELETE_HBAR_ALLOWANCE_TOOL = "delete_hbar_allowance_tool";
var tool20 = (context) => ({
  method: DELETE_HBAR_ALLOWANCE_TOOL,
  name: "Delete HBAR Allowance",
  description: deleteHbarAllowancePrompt(context),
  parameters: deleteHbarAllowanceParameters(context),
  execute: deleteHbarAllowance
});
var delete_hbar_allowance_default = tool20;

// src/plugins/core-token-plugin/tools/fungible-token/approve-token-allowance.ts
import { Status as Status21 } from "@hashgraph/sdk";
var approveTokenAllowancePrompt = (context = {}) => {
  const contextSnippet = PromptGenerator.getContextSnippet(context);
  const ownerAccountDesc = PromptGenerator.getAccountParameterDescription(
    "ownerAccountId",
    context
  );
  const usageInstructions = PromptGenerator.getParameterUsageInstructions();
  return `
${contextSnippet}

This tool approves allowances for one or more fungible tokens from the owner to the spender.

Parameters:
- ${ownerAccountDesc}
- spenderAccountId (string, required): Spender account ID
- tokenApprovals (array, required): List of approvals. Each item:
  - tokenId (string): Token ID
  - amount (number): Amount of tokens to approve (must be a positive integer)
- transactionMemo (string, optional): Optional memo for the transaction
${usageInstructions}
`;
};
var postProcess21 = (response) => {
  return `Fungible token allowance(s) approved successfully. Transaction ID: ${response.transactionId}`;
};
var approveTokenAllowance = async (client, context, params) => {
  try {
    const mirrornodeService = getMirrornodeService(context.mirrornodeService, client.ledgerId);
    const normalisedParams = await HederaParameterNormaliser.normaliseApproveTokenAllowance(
      params,
      context,
      client,
      mirrornodeService
    );
    const tx = HederaBuilder.approveTokenAllowance(normalisedParams);
    return await handleTransaction(tx, client, context, postProcess21);
  } catch (error) {
    const desc = "Failed to approve token allowance";
    const message = desc + (error instanceof Error ? `: ${error.message}` : "");
    console.error("[approve_token_allowance_tool]", message);
    return { raw: { status: Status21.InvalidTransaction, error: message }, humanMessage: message };
  }
};
var APPROVE_TOKEN_ALLOWANCE_TOOL = "approve_token_allowance_tool";
var tool21 = (context) => ({
  method: APPROVE_TOKEN_ALLOWANCE_TOOL,
  name: "Approve Token Allowance",
  description: approveTokenAllowancePrompt(context),
  parameters: approveTokenAllowanceParameters(context),
  execute: approveTokenAllowance
});
var approve_token_allowance_default = tool21;

// src/plugins/core-token-plugin/tools/fungible-token/delete-token-allowance.ts
import { Status as Status22 } from "@hashgraph/sdk";
var deleteTokenAllowancePrompt = (context = {}) => {
  const contextSnippet = PromptGenerator.getContextSnippet(context);
  const ownerAccountDesc = PromptGenerator.getAccountParameterDescription(
    "ownerAccountId",
    context
  );
  const usageInstructions = PromptGenerator.getParameterUsageInstructions();
  return `
${contextSnippet}
This tool deletes token allowance(s) from the owner to the spender.

Parameters:
- ${ownerAccountDesc}
- spenderAccountId (string, required): Spender account ID
- tokenIds (array, required): List of token IDs whose allowances should be removed
- transactionMemo (string, optional): Optional memo for the transaction
${usageInstructions}
Example: "Delete token allowance for account 0.0.123 on token 0.0.456". Means that 0.0.123 is the spenderId, 0.0.456 is the tokenId and the ownerId is taken from context or default operator.
Example 2: "Delete token allowance given from 0.0.1001 to account 0.0.2002 for token 0.0.3003". Means that 0.0.1001 is the ownerId, 0.0.2002 is the spenderId and 0.0.3003 is the tokenId.
`;
};
var postProcess22 = (response) => {
  return `Token allowance(s) deleted successfully. Transaction ID: ${response.transactionId}`;
};
var deleteTokenAllowance = async (client, context, params) => {
  try {
    const mirrornodeService = getMirrornodeService(context.mirrornodeService, client.ledgerId);
    const normalisedParams = await HederaParameterNormaliser.normaliseDeleteTokenAllowance(
      params,
      context,
      client,
      mirrornodeService
    );
    const tx = HederaBuilder.approveTokenAllowance(normalisedParams);
    return await handleTransaction(tx, client, context, postProcess22);
  } catch (error) {
    const desc = "Failed to delete token allowance(s).";
    const message = desc + (error instanceof Error ? `: ${error.message}` : "");
    console.error("[delete_token_allowance_tool]", message);
    return { raw: { status: Status22.InvalidTransaction, error: message }, humanMessage: message };
  }
};
var DELETE_TOKEN_ALLOWANCE_TOOL = "delete_token_allowance_tool";
var tool22 = (context) => ({
  method: DELETE_TOKEN_ALLOWANCE_TOOL,
  name: "Delete Token Allowance",
  description: deleteTokenAllowancePrompt(context),
  parameters: deleteTokenAllowanceParameters(context),
  execute: deleteTokenAllowance
});
var delete_token_allowance_default = tool22;

// src/plugins/core-account-plugin/index.ts
var coreAccountPlugin = {
  name: "core-account-plugin",
  version: "1.0.0",
  description: "A plugin for the Hedera Account Service",
  tools: (context) => {
    return [
      transfer_hbar_default(context),
      approve_hbar_allowance_default(context),
      delete_hbar_allowance_default(context),
      delete_account_default(context),
      update_account_default(context),
      create_account_default(context),
      sign_schedule_transaction_default(context),
      schedule_delete_default(context),
      approve_token_allowance_default(context),
      transfer_hbar_with_allowance_default(context),
      delete_token_allowance_default(context)
    ];
  }
};
var coreAccountPluginToolNames = {
  TRANSFER_HBAR_TOOL,
  APPROVE_HBAR_ALLOWANCE_TOOL,
  DELETE_HBAR_ALLOWANCE_TOOL,
  CREATE_ACCOUNT_TOOL,
  DELETE_ACCOUNT_TOOL,
  UPDATE_ACCOUNT_TOOL,
  SIGN_SCHEDULE_TRANSACTION_TOOL,
  SCHEDULE_DELETE_TOOL,
  APPROVE_TOKEN_ALLOWANCE_TOOL,
  DELETE_TOKEN_ALLOWANCE_TOOL,
  TRANSFER_HBAR_WITH_ALLOWANCE_TOOL
};

// src/plugins/core-consensus-plugin/tools/consensus/create-topic.ts
import { Status as Status23 } from "@hashgraph/sdk";
var createTopicPrompt = (_context = {}) => {
  const usageInstructions = PromptGenerator.getParameterUsageInstructions();
  return `
This tool will create a new topic on the Hedera network.

Parameters:
- topicMemo (str, optional): A memo for the topic
- transactionMemo (str, optional): An optional memo to include on the submitted transaction
- isSubmitKey (bool, optional): Whether to set a submit key for the topic. Set to true if user wants to set a submit key, otherwise false
${usageInstructions}
`;
};
var postProcess23 = (response) => {
  return `Topic created successfully with topic id ${response.topicId?.toString()} and transaction id ${response.transactionId.toString()}`;
};
var createTopic = async (client, context, params) => {
  try {
    const mirrornodeService = getMirrornodeService(
      context.mirrornodeService,
      client.ledgerId
    );
    const normalisedParams = await HederaParameterNormaliser.normaliseCreateTopicParams(
      params,
      context,
      client,
      mirrornodeService
    );
    const tx = HederaBuilder.createTopic(normalisedParams);
    const result = await handleTransaction(tx, client, context, postProcess23);
    return result;
  } catch (error) {
    const desc = "Failed to create topic";
    const message = desc + (error instanceof Error ? `: ${error.message}` : "");
    console.error("[create_topic_tool]", message);
    return { raw: { status: Status23.InvalidTransaction, error: message }, humanMessage: message };
  }
};
var CREATE_TOPIC_TOOL = "create_topic_tool";
var tool23 = (context) => ({
  method: CREATE_TOPIC_TOOL,
  name: "Create Topic",
  description: createTopicPrompt(context),
  parameters: createTopicParameters(context),
  execute: createTopic
});
var create_topic_default = tool23;

// src/plugins/core-consensus-plugin/tools/consensus/delete-topic.ts
import { Status as Status24 } from "@hashgraph/sdk";
var deleteTopicPrompt = (_context = {}) => {
  const usageInstructions = PromptGenerator.getParameterUsageInstructions();
  return `
This tool will delete a given Hedera network topic.

Parameters:
- topicId (str, required): id of topic to delete
${usageInstructions}
`;
};
var postProcess24 = (response) => {
  return `Topic with id ${response.topicId?.toString()} deleted successfully. Transaction id ${response.transactionId.toString()}`;
};
var deleteTopic = async (client, context, params) => {
  try {
    const mirrornodeService = getMirrornodeService(
      context.mirrornodeService,
      client.ledgerId
    );
    const normalisedParams = HederaParameterNormaliser.normaliseDeleteTopic(
      params,
      context,
      client,
      mirrornodeService
    );
    const tx = HederaBuilder.deleteTopic(normalisedParams);
    return await handleTransaction(tx, client, context, postProcess24);
  } catch (error) {
    const desc = "Failed to delete the topic";
    const message = desc + (error instanceof Error ? `: ${error.message}` : "");
    console.error("[delete_topic_tool]", message);
    return { raw: { status: Status24.InvalidTransaction, error: message }, humanMessage: message };
  }
};
var DELETE_TOPIC_TOOL = "delete_topic_tool";
var tool24 = (context) => ({
  method: DELETE_TOPIC_TOOL,
  name: "Delete Topic",
  description: deleteTopicPrompt(context),
  parameters: deleteTopicParameters(context),
  execute: deleteTopic
});
var delete_topic_default = tool24;

// src/plugins/core-consensus-plugin/tools/consensus/submit-topic-message.ts
import { Status as Status25 } from "@hashgraph/sdk";
var submitTopicMessagePrompt = (context = {}) => {
  const usageInstructions = PromptGenerator.getParameterUsageInstructions();
  return `
This tool will submit a message to a topic on the Hedera network.

Parameters:
- topicId (str, required): The ID of the topic to submit the message to
- message (str, required): The message to submit to the topic
- transactionMemo (str, optional): An optional memo to include on the transaction
${PromptGenerator.getScheduledTransactionParamsDescription(context)}
${usageInstructions}
`;
};
var postProcess25 = (response) => {
  return `Message submitted successfully with transaction id ${response.transactionId.toString()}`;
};
var submitTopicMessage = async (client, context, params) => {
  try {
    const normalisedParams = await HederaParameterNormaliser.normaliseSubmitTopicMessage(
      params,
      context,
      client
    );
    const tx = HederaBuilder.submitTopicMessage(normalisedParams);
    return await handleTransaction(tx, client, context, postProcess25);
  } catch (error) {
    const desc = "Failed to submit message to topic";
    const message = desc + (error instanceof Error ? `: ${error.message}` : "");
    console.error("[submit_topic_message_tool]", message);
    return { raw: { status: Status25.InvalidTransaction, error: message }, humanMessage: message };
  }
};
var SUBMIT_TOPIC_MESSAGE_TOOL = "submit_topic_message_tool";
var tool25 = (context) => ({
  method: SUBMIT_TOPIC_MESSAGE_TOOL,
  name: "Submit Topic Message",
  description: submitTopicMessagePrompt(context),
  parameters: submitTopicMessageParameters(context),
  execute: submitTopicMessage
});
var submit_topic_message_default = tool25;

// src/plugins/core-consensus-plugin/tools/consensus/update-topic.ts
import { PublicKey as PublicKey7, Status as Status26 } from "@hashgraph/sdk";
var checkValidityOfUpdates2 = async (params, mirrornode, userPublicKey) => {
  const topicDetails = await mirrornode.getTopicInfo(params.topicId.toString());
  if (!topicDetails) {
    throw new Error("Topic not found");
  }
  if (topicDetails.admin_key === void 0) {
    throw new Error("Topic does not have an admin key. It cannot be updated.");
  }
  if (topicDetails.admin_key.key !== userPublicKey.toStringRaw()) {
    console.error(
      `topicDetails.admin_key.key: ${topicDetails.admin_key?.key} vs userPublicKey: ${userPublicKey.toStringRaw()}`
    );
    throw new Error(
      "You do not have permission to update this topic. The adminKey does not match your public key."
    );
  }
  const keyChecks = {
    adminKey: "admin_key",
    submitKey: "submit_key"
  };
  for (const [paramKey, topicField] of Object.entries(keyChecks)) {
    const userValue = params[paramKey];
    const topicKey = topicDetails[topicField];
    if (userValue instanceof PublicKey7 && !topicKey) {
      throw new Error(`Cannot update ${paramKey}: topic was created without a ${paramKey}`);
    }
  }
};
var updateTopicPrompt = (context = {}) => {
  const contextSnippet = PromptGenerator.getContextSnippet(context);
  const topicDesc = PromptGenerator.getAnyAddressParameterDescription("topicId", context);
  const usageInstructions = PromptGenerator.getParameterUsageInstructions();
  return `
${contextSnippet}
This tool will update an existing Hedera Consensus Topic. Only the fields provided will be updated.
Key fields (adminKey, submitKey) must contain **Hedera-compatible public keys (as strings) or boolean (true/false)**. You can provide these in one of three ways:
1. **Boolean true** \u2013 Set this field to use user/operator key. Injecting of the key will be handled automatically.
2. **Not provided** \u2013 The field will not be updated.
3. **String** \u2013 Provide a Hedera-compatible public key string to set a field explicitly.

Parameters:
- ${topicDesc}
- topicMemo (string, optional): New memo for the topic.
- adminKey (boolean|string, optional): New admin key. Pass true to use your operator key, or provide a public key string.
- submitKey (boolean|string, optional): New submit key. Pass true to use your operator key, or provide a public key string.
- autoRenewAccountId (string, optional): Account to automatically pay for renewal.
- autoRenewPeriod (number, optional): Auto renew period in seconds.
- expirationTime (string|Date, optional): New expiration time for the topic (ISO string or Date).
Examples:
- If the user asks for "my key" \u2192 set the field to \`true\`.
- If the user does not mention the key \u2192 do not set the field.
- If the user provides a key \u2192 set the field to the provided public key string.

If the user provides multiple fields in a single request, 
combine them into **one tool call** with all parameters together.
${usageInstructions}
`;
};
var postProcess26 = (response) => {
  return `Topic successfully updated. Transaction ID: ${response.transactionId}`;
};
var updateTopic = async (client, context, params) => {
  try {
    const normalisedParams = await HederaParameterNormaliser.normaliseUpdateTopic(
      params,
      context,
      client
    );
    const mirrornodeService = getMirrornodeService(context.mirrornodeService, client.ledgerId);
    const userPublicKey = await AccountResolver.getDefaultPublicKey(context, client);
    await checkValidityOfUpdates2(normalisedParams, mirrornodeService, userPublicKey);
    const tx = HederaBuilder.updateTopic(normalisedParams);
    return await handleTransaction(tx, client, context, postProcess26);
  } catch (error) {
    const desc = "Failed to update topic";
    const message = desc + (error instanceof Error ? `: ${error.message}` : "");
    console.error("[update_topic_tool]", message);
    return {
      raw: { status: Status26.InvalidTransaction, error: message },
      humanMessage: message
    };
  }
};
var UPDATE_TOPIC_TOOL = "update_topic_tool";
var tool26 = (context) => ({
  method: UPDATE_TOPIC_TOOL,
  name: "Update Topic",
  description: updateTopicPrompt(context),
  parameters: updateTopicParameters(context),
  execute: updateTopic
});
var update_topic_default = tool26;

// src/plugins/core-consensus-plugin/index.ts
var coreConsensusPlugin = {
  name: "core-consensus-plugin",
  version: "1.0.0",
  description: "A plugin for the Hedera Consensus Service",
  tools: (context) => {
    return [
      create_topic_default(context),
      submit_topic_message_default(context),
      delete_topic_default(context),
      update_topic_default(context)
    ];
  }
};
var coreConsensusPluginToolNames = {
  CREATE_TOPIC_TOOL,
  SUBMIT_TOPIC_MESSAGE_TOOL,
  DELETE_TOPIC_TOOL,
  UPDATE_TOPIC_TOOL
};

// src/shared/hedera-utils/hbar-conversion-utils.ts
function toHbar(tinyBars) {
  return tinyBars.div(1e8);
}

// src/plugins/core-queries-plugin/tools/queries/get-hbar-balance-query.ts
var getHbarBalanceQueryPrompt = (context = {}) => {
  const contextSnippet = PromptGenerator.getContextSnippet(context);
  const accountDesc = PromptGenerator.getAccountParameterDescription("accountId", context);
  const usageInstructions = PromptGenerator.getParameterUsageInstructions();
  return `
${contextSnippet}

This tool will return the HBAR balance for a given Hedera account.

Parameters:
- ${accountDesc}
${usageInstructions}
`;
};
var postProcess27 = (hbarBalance, accountId) => {
  return `Account ${accountId} has a balance of ${hbarBalance} HBAR`;
};
var getHbarBalanceQuery = async (client, context, params) => {
  try {
    const normalisedParams = HederaParameterNormaliser.normaliseHbarBalanceParams(
      params,
      context,
      client
    );
    const mirrornodeService = getMirrornodeService(context.mirrornodeService, client.ledgerId);
    const balance = await mirrornodeService.getAccountHbarBalance(
      normalisedParams.accountId
    );
    return {
      raw: { accountId: normalisedParams.accountId, hbarBalance: toHbar(balance).toString() },
      humanMessage: postProcess27(toHbar(balance).toString(), normalisedParams.accountId)
    };
  } catch (error) {
    const desc = "Failed to get HBAR balance";
    const message = desc + (error instanceof Error ? `: ${error.message}` : "");
    console.error("[get_hbar_balance_query_tool]", message);
    return { raw: { error: message }, humanMessage: message };
  }
};
var GET_HBAR_BALANCE_QUERY_TOOL = "get_hbar_balance_query_tool";
var tool27 = (context) => ({
  method: GET_HBAR_BALANCE_QUERY_TOOL,
  name: "Get HBAR Balance",
  description: getHbarBalanceQueryPrompt(context),
  parameters: accountBalanceQueryParameters(context),
  execute: getHbarBalanceQuery
});
var get_hbar_balance_query_default = tool27;

// src/plugins/core-queries-plugin/tools/queries/get-account-query.ts
import { Status as Status27 } from "@hashgraph/sdk";
var getAccountQueryPrompt = (context = {}) => {
  const contextSnippet = PromptGenerator.getContextSnippet(context);
  const usageInstructions = PromptGenerator.getParameterUsageInstructions();
  return `
${contextSnippet}

This tool will return the account information for a given Hedera account.

Parameters:
- accountId (str, required): The account ID to query
${usageInstructions}
`;
};
var postProcess28 = (account) => {
  return `Details for ${account.accountId}
Balance: ${account.balance.balance.toString()}
Public Key: ${account.accountPublicKey},
EVM address: ${account.evmAddress},
`;
};
var getAccountQuery = async (client, context, params) => {
  try {
    const mirrornodeService = getMirrornodeService(context.mirrornodeService, client.ledgerId);
    const account = await mirrornodeService.getAccount(params.accountId);
    return {
      raw: { accountId: params.accountId, account },
      humanMessage: postProcess28(account)
    };
  } catch (error) {
    const desc = "Failed to get account query";
    const message = desc + (error instanceof Error ? `: ${error.message}` : "");
    console.error("[get_account_query_tool]", message);
    return { raw: { status: Status27.InvalidTransaction, error: message }, humanMessage: message };
  }
};
var GET_ACCOUNT_QUERY_TOOL = "get_account_query_tool";
var tool28 = (context) => ({
  method: GET_ACCOUNT_QUERY_TOOL,
  name: "Get Account Query",
  description: getAccountQueryPrompt(context),
  parameters: accountQueryParameters(context),
  execute: getAccountQuery
});
var get_account_query_default = tool28;

// src/plugins/core-queries-plugin/tools/queries/get-account-token-balances-query.ts
var getAccountTokenBalancesQueryPrompt = (context = {}) => {
  const contextSnippet = PromptGenerator.getContextSnippet(context);
  const accountDesc = PromptGenerator.getAccountParameterDescription("accountId", context);
  const usageInstructions = PromptGenerator.getParameterUsageInstructions();
  return `
${contextSnippet}

This tool will return the token balances for a given Hedera account.

Parameters:
- ${accountDesc}
- tokenId (str, optional): The token ID to query for. If not provided, all token balances will be returned
${usageInstructions}
`;
};
var postProcess29 = (tokenBalances, accountId) => {
  const balancesText = tokenBalances.tokens.map(
    (token) => `  Token: ${token.token_id}, Balance: ${token.balance}, Decimals: ${token.decimals}`
  ).join("\n");
  return `Details for ${accountId}
--- Token Balances ---
${balancesText}`;
};
var getAccountTokenBalancesQuery = async (client, context, params) => {
  try {
    const normalisedParams = HederaParameterNormaliser.normaliseAccountTokenBalancesParams(
      params,
      context,
      client
    );
    const mirrornodeService = getMirrornodeService(context.mirrornodeService, client.ledgerId);
    const tokenBalances = await mirrornodeService.getAccountTokenBalances(
      normalisedParams.accountId,
      normalisedParams.tokenId
    );
    return {
      raw: { accountId: normalisedParams.accountId, tokenBalances },
      humanMessage: postProcess29(tokenBalances, normalisedParams.accountId)
    };
  } catch (error) {
    const desc = "Failed to get account token balances";
    const message = desc + (error instanceof Error ? `: ${error.message}` : "");
    console.error("[get_account_token_balances_query_tool]", message);
    return { raw: { error: message }, humanMessage: message };
  }
};
var GET_ACCOUNT_TOKEN_BALANCES_QUERY_TOOL = "get_account_token_balances_query_tool";
var tool29 = (context) => ({
  method: GET_ACCOUNT_TOKEN_BALANCES_QUERY_TOOL,
  name: "Get Account Token Balances",
  description: getAccountTokenBalancesQueryPrompt(context),
  parameters: accountTokenBalancesQueryParameters(context),
  execute: getAccountTokenBalancesQuery
});
var get_account_token_balances_query_default = tool29;

// src/plugins/core-queries-plugin/tools/queries/get-topic-messages-query.ts
var getTopicMessagesQueryPrompt = (context = {}) => {
  const contextSnippet = PromptGenerator.getContextSnippet(context);
  const usageInstructions = PromptGenerator.getParameterUsageInstructions();
  return `
${contextSnippet}

This tool will return the messages for a given Hedera topic.

Parameters:
- topicId (str, required): The topic ID to query
- startTime (datetime, optional): The start datetime to query. If set, the messages will be returned after this datetime
- endTime (datetime, optional): The end datetime to query. If set, the messages will be returned before this datetime
- limit (int, optional): The limit of messages to query. If set, the number of messages to return
${usageInstructions}
`;
};
var postProcess30 = (messages, topicId) => {
  const messagesText = messages.map(
    (message) => `${Buffer.from(message.message, "base64").toString("utf-8")} - posted at: ${message.consensus_timestamp}
`
  );
  return `Messages for topic ${topicId}:
  --- Messages ---
  ${messagesText}
  `;
};
var getTopicMessagesQueryParams = (params) => {
  return {
    topicId: params.topicId,
    lowerTimestamp: params.startTime ? `${Math.floor(new Date(params.startTime).getTime() / 1e3)}.000000000` : "",
    upperTimestamp: params.endTime ? `${Math.floor(new Date(params.endTime).getTime() / 1e3)}.000000000` : "",
    limit: params.limit || 100
  };
};
var convertMessagesFromBase64ToString = (messages) => {
  return messages.map((message) => {
    return {
      ...message,
      message: Buffer.from(message.message, "base64").toString("utf-8")
    };
  });
};
var getTopicMessagesQuery = async (client, context, params) => {
  try {
    const mirrornodeService = getMirrornodeService(context.mirrornodeService, client.ledgerId);
    const messages = await mirrornodeService.getTopicMessages(getTopicMessagesQueryParams(params));
    return {
      raw: {
        topicId: messages.topicId,
        messages: convertMessagesFromBase64ToString(messages.messages)
      },
      humanMessage: postProcess30(messages.messages, params.topicId)
    };
  } catch (error) {
    const desc = "Failed to get topic messages";
    const message = desc + (error instanceof Error ? `: ${error.message}` : "");
    console.error("[get_topic_messages_query_tool]", message);
    return { raw: { error: message }, humanMessage: message };
  }
};
var GET_TOPIC_MESSAGES_QUERY_TOOL = "get_topic_messages_query_tool";
var tool30 = (context) => ({
  method: GET_TOPIC_MESSAGES_QUERY_TOOL,
  name: "Get Topic Messages",
  description: getTopicMessagesQueryPrompt(context),
  parameters: topicMessagesQueryParameters(context),
  execute: getTopicMessagesQuery
});
var get_topic_messages_query_default = tool30;

// src/plugins/core-queries-plugin/tools/queries/get-token-info-query.ts
var getTokenInfoQueryPrompt = (context = {}) => {
  const contextSnippet = PromptGenerator.getContextSnippet(context);
  const usageInstructions = PromptGenerator.getParameterUsageInstructions();
  return `
${contextSnippet}

This tool will return the information for a given Hedera token.

Parameters:
- tokenId (str): The token ID to query for.
${usageInstructions}
`;
};
var postProcess31 = (tokenInfo) => {
  const formatSupply = (supply) => {
    if (!supply) return "N/A";
    const decimals = Number(tokenInfo.decimals || "0");
    const amount = Number(supply);
    if (isNaN(amount)) return supply;
    return (amount / 10 ** decimals).toLocaleString();
  };
  const formatKey = (key) => {
    if (!key) return "Not Set";
    return key._type ? `${key.key}` : "Present";
  };
  const supplyType = tokenInfo.supply_type === "INFINITE" ? "Infinite" : tokenInfo.max_supply || "Finite";
  const freezeStatus = tokenInfo.freeze_default ? "Frozen" : "Active";
  return `Here are the details for token **${tokenInfo.token_id}**:

- **Token Name**: ${tokenInfo.name}
- **Token Symbol**: ${tokenInfo.symbol}
- **Token Type**: ${tokenInfo.type || "N/A"}
- **Decimals**: ${tokenInfo.decimals}
- **Max Supply**: ${formatSupply(tokenInfo.max_supply)}
- **Current Supply**: ${formatSupply(tokenInfo.total_supply)}
- **Supply Type**: ${supplyType}
- **Treasury Account ID**: ${tokenInfo.treasury_account_id || "N/A"}
- **Status (Deleted/Active)**: ${tokenInfo.deleted ? "Deleted" : "Active"}
- **Status (Frozen/Active)**: ${freezeStatus}

**Keys**:
- Admin Key: ${formatKey(tokenInfo.admin_key)}
- Supply Key: ${formatKey(tokenInfo.supply_key)}
- Wipe Key: ${formatKey(tokenInfo.wipe_key)}
- KYC Key: ${formatKey(tokenInfo.kyc_key)}
- Freeze Key: ${formatKey(tokenInfo.freeze_key)}
- Fee Schedule Key: ${formatKey(tokenInfo.fee_schedule_key)}
- Pause Key: ${formatKey(tokenInfo.pause_key)}
- Metadata Key: ${formatKey(tokenInfo.metadata_key)}

${tokenInfo.memo ? `**Memo**: ${tokenInfo.memo}` : ""}
`;
};
var getTokenInfoQuery = async (client, context, params) => {
  try {
    const mirrornodeService = getMirrornodeService(context.mirrornodeService, client.ledgerId);
    const tokenInfo = {
      ...await mirrornodeService.getTokenInfo(params.tokenId),
      token_id: params.tokenId
    };
    return {
      raw: { tokenId: params.tokenId, tokenInfo },
      humanMessage: postProcess31(tokenInfo)
    };
  } catch (error) {
    const desc = "Failed to get token info";
    const message = desc + (error instanceof Error ? `: ${error.message}` : "");
    console.error("[get_token_info_query_tool]", message);
    return { raw: { error: message }, humanMessage: message };
  }
};
var GET_TOKEN_INFO_QUERY_TOOL = "get_token_info_query_tool";
var tool31 = (context) => ({
  method: GET_TOKEN_INFO_QUERY_TOOL,
  name: "Get Token Info",
  description: getTokenInfoQueryPrompt(context),
  parameters: tokenInfoQueryParameters(context),
  execute: getTokenInfoQuery
});
var get_token_info_query_default = tool31;

// src/plugins/core-queries-plugin/index.ts
var coreQueriesPlugin = {
  name: "core-queries-plugin",
  version: "1.0.0",
  description: "A plugin for the Hedera Queries Service (DEPRECATED)",
  tools: (context) => {
    return [
      get_hbar_balance_query_default(context),
      get_account_query_default(context),
      get_account_token_balances_query_default(context),
      get_topic_messages_query_default(context),
      get_token_info_query_default(context)
    ];
  }
};
var coreQueriesPluginToolNames = {
  GET_HBAR_BALANCE_QUERY_TOOL,
  GET_ACCOUNT_QUERY_TOOL,
  GET_ACCOUNT_TOKEN_BALANCES_QUERY_TOOL,
  GET_TOPIC_MESSAGES_QUERY_TOOL,
  GET_TOKEN_INFO_QUERY_TOOL
};

// src/shared/parameter-schemas/core-misc.zod.ts
import { z as z8 } from "zod";
var exchangeRateQueryParameters = (_context) => z8.object({
  timestamp: z8.string().describe("Historical timestamp to query (seconds or nanos since epoch)").optional()
});

// src/plugins/core-misc-query-plugin/tools/queries/get-exchange-rate-query.ts
var getExchangeRatePrompt = (context = {}) => {
  const contextSnippet = PromptGenerator.getContextSnippet(context);
  const usageInstructions = PromptGenerator.getParameterUsageInstructions();
  return `
${contextSnippet}

This tool returns the Hedera network HBAR exchange rate from the Mirror Node.

Parameters:
- timestamp (str, optional): Historical timestamp to query. Pass seconds or nanos since epoch (e.g., 1726000000.123456789). If omitted, returns the latest rate.
${usageInstructions}
`;
};
var calculateUsdPerHBAR = (cent_equivalent, hbar_equivalent) => {
  return cent_equivalent / 100 / hbar_equivalent;
};
var postProcess32 = (rates) => {
  const { current_rate, next_rate, timestamp } = rates;
  const usdPerHBAR = calculateUsdPerHBAR(
    current_rate.cent_equivalent,
    current_rate.hbar_equivalent
  );
  const nextUsdPerHBAR = calculateUsdPerHBAR(next_rate.cent_equivalent, next_rate.hbar_equivalent);
  return `
  Details for timestamp: ${timestamp}
  
  Current exchange rate: ${usdPerHBAR}
  Expires at ${new Date(current_rate.expiration_time * 1e3).toISOString()})
  
  Next exchange rate: ${nextUsdPerHBAR}
  Expires at ${new Date(next_rate.expiration_time * 1e3).toISOString()})`;
};
var getExchangeRateQuery = async (client, context, params) => {
  try {
    const mirrornodeService = getMirrornodeService(context.mirrornodeService, client.ledgerId);
    const rates = await mirrornodeService.getExchangeRate(params.timestamp);
    return {
      raw: rates,
      humanMessage: postProcess32(rates)
    };
  } catch (error) {
    console.error("[GetExchangeRate] Error getting exchange rate", error);
    const message = error instanceof Error ? error.message : "Failed to get exchange rate";
    return {
      raw: { error: message },
      humanMessage: message
    };
  }
};
var GET_EXCHANGE_RATE_TOOL = "get_exchange_rate_tool";
var tool32 = (context) => ({
  method: GET_EXCHANGE_RATE_TOOL,
  name: "Get Exchange Rate",
  description: getExchangeRatePrompt(context),
  parameters: exchangeRateQueryParameters(context),
  execute: getExchangeRateQuery
});
var get_exchange_rate_query_default = tool32;

// src/plugins/core-misc-query-plugin/index.ts
var coreMiscQueriesPlugin = {
  name: "core-misc-queries-plugin",
  version: "1.0.0",
  description: "A plugin for Hedera Misc Queries",
  tools: (context) => {
    return [get_exchange_rate_query_default(context)];
  }
};
var coreMiscQueriesPluginsToolNames = {
  GET_EXCHANGE_RATE_TOOL
};

// src/plugins/core-evm-plugin/tools/erc20/create-erc20.ts
import { Status as Status28, TransactionRecordQuery } from "@hashgraph/sdk";

// src/shared/constants/contracts.ts
import { LedgerId as LedgerId2 } from "@hashgraph/sdk";
var TESTNET_ERC20_FACTORY_ADDRESS = "0.0.6471814";
var TESTNET_ERC721_FACTORY_ADDRESS = "0.0.6510666";
var ERC20_FACTORY_ADDRESSES = /* @__PURE__ */ new Map([
  [LedgerId2.TESTNET.toString(), TESTNET_ERC20_FACTORY_ADDRESS]
  // Current testnet address
]);
var ERC721_FACTORY_ADDRESSES = /* @__PURE__ */ new Map([
  [LedgerId2.TESTNET.toString(), TESTNET_ERC721_FACTORY_ADDRESS]
  // Current testnet address
]);
var ERC20_FACTORY_ABI = [
  "function deployToken(string memory name_, string memory symbol_, uint8 decimals_, uint256 initialSupply_) external returns (address)"
];
var ERC721_FACTORY_ABI = [
  "function deployToken(string memory name_, string memory symbol_, string memory baseURI_) external returns (address)"
];
var ERC20_TRANSFER_FUNCTION_NAME = "transfer";
var ERC20_TRANSFER_FUNCTION_ABI = [
  "function transfer(address to, uint256 amount) external returns (bool)"
];
var ERC721_TRANSFER_FUNCTION_NAME = "transferFrom";
var ERC721_TRANSFER_FUNCTION_ABI = [
  "function transferFrom(address from, address to, uint256 tokenId) external returns (bool)"
];
var ERC721_MINT_FUNCTION_NAME = "safeMint";
var ERC721_MINT_FUNCTION_ABI = ["function safeMint(address to) external returns (bool)"];
function getERC20FactoryAddress(ledgerId) {
  const address = ERC20_FACTORY_ADDRESSES.get(ledgerId.toString());
  if (!address) {
    throw new Error(`Network type ${ledgerId} not supported for ERC20 factory`);
  }
  return address;
}
function getERC721FactoryAddress(ledgerId) {
  const address = ERC721_FACTORY_ADDRESSES.get(ledgerId.toString());
  if (!address) {
    throw new Error(`Network type ${ledgerId} not supported for ERC721 factory`);
  }
  return address;
}

// src/plugins/core-evm-plugin/tools/erc20/create-erc20.ts
var createERC20Prompt = (context = {}) => `
${PromptGenerator.getContextSnippet(context)}

This tool creates an ERC20 token on Hedera by calling the BaseERC20Factory contract. ERC20 is an EVM compatible fungible token.

Parameters:
- tokenName (str, required): The name of the token
- tokenSymbol (str, required): The symbol of the token
- decimals (int, optional): The number of decimals the token supports. Defaults to 18
- initialSupply (int, optional): The initial supply of the token. Defaults to 0
- ${PromptGenerator.getScheduledTransactionParamsDescription(context)}

${PromptGenerator.getParameterUsageInstructions()}
`;
var getERC20Address = async (client, tx) => {
  const record = await new TransactionRecordQuery().setTransactionId(tx.transactionId).execute(client);
  return "0x" + record.contractFunctionResult?.getAddress(0);
};
var postProcess33 = (erc20Address, response) => response?.scheduleId ? `Scheduled creation of ERC20 successfully.
Transaction ID: ${response.transactionId}
Schedule ID: ${response.scheduleId.toString()}` : `ERC20 token created successfully at address ${erc20Address ?? "unknown"}`;
var createERC20 = async (client, context, params) => {
  try {
    const factoryAddress = getERC20FactoryAddress(client.ledgerId);
    const txParams = await HederaParameterNormaliser.normaliseCreateERC20Params(
      params,
      factoryAddress,
      ERC20_FACTORY_ABI,
      "deployToken",
      context,
      client
    );
    const tx = HederaBuilder.executeTransaction(txParams);
    const result = await handleTransaction(tx, client, context);
    if (context.mode === "returnBytes" /* RETURN_BYTES */) return result;
    const raw = result.raw;
    const erc20Address = await getERC20Address(client, raw);
    const humanMessage = postProcess33(erc20Address, raw);
    return { ...result, erc20Address, humanMessage };
  } catch (error) {
    const message = "Failed to create ERC20 token" + (error instanceof Error ? `: ${error.message}` : "");
    console.error("[create_erc20_tool]", message);
    return {
      raw: { status: Status28.InvalidTransaction, error: message },
      humanMessage: message
    };
  }
};
var CREATE_ERC20_TOOL = "create_erc20_tool";
var tool33 = (context) => ({
  method: CREATE_ERC20_TOOL,
  name: "Create ERC20 Token",
  description: createERC20Prompt(context),
  parameters: createERC20Parameters(context),
  execute: createERC20
});
var create_erc20_default = tool33;

// src/plugins/core-evm-plugin/tools/erc20/transfer-erc20.ts
import { Status as Status29 } from "@hashgraph/sdk";
var transferERC20Prompt = (context = {}) => {
  const contextSnippet = PromptGenerator.getContextSnippet(context);
  const usageInstructions = PromptGenerator.getParameterUsageInstructions();
  return `
${contextSnippet}

This tool will transfer a given amount of an existing ERC20 token on Hedera. ERC20 is an EVM compatible fungible token.

Parameters:
- contractId (str, required): The id of the ERC20 contract. This can be the EVM address or the Hedera account id.
- recipientAddress (str, required): The EVM or Hedera address to which the tokens will be transferred. This can be the EVM address or the Hedera account id.
- amount (number, required): The amount to be transferred
- ${PromptGenerator.getScheduledTransactionParamsDescription(context)}

${usageInstructions}

Example: "Transfer 1 ERC20 token 0.0.6473135 to 0xd94dc7f82f103757f715514e4a37186be6e4580b" means transferring the amount of 1 of the ERC20 token with contract id 0.0.6473135 to the 0xd94dc7f82f103757f715514e4a37186be6e4580b EVM address.
Example: "Transfer 1 ERC20 token 0xd94dc7f82f103757f715514e4a37186be6e4580b to 0.0.6473135" means transferring the amount of 1 of the ERC20 token with contract id 0xd94dc7f82f103757f715514e4a37186be6e4580b to the 0.0.6473135 Hedera account id.
`;
};
var postProcess34 = (response) => response?.scheduleId ? `Scheduled transfer of ERC20 successfully.
Transaction ID: ${response.transactionId}
Schedule ID: ${response.scheduleId.toString()}` : `ERC20 token transferred successfully.`;
var transferERC20 = async (client, context, params) => {
  const mirrorNode = getMirrornodeService(context.mirrornodeService, client.ledgerId);
  try {
    const normalisedParams = await HederaParameterNormaliser.normaliseTransferERC20Params(
      params,
      ERC20_TRANSFER_FUNCTION_ABI,
      ERC20_TRANSFER_FUNCTION_NAME,
      context,
      mirrorNode,
      client
    );
    const tx = HederaBuilder.executeTransaction(normalisedParams);
    return await handleTransaction(tx, client, context, postProcess34);
  } catch (error) {
    const desc = "Failed to transfer ERC20";
    const message = desc + (error instanceof Error ? `: ${error.message}` : "");
    console.error("[transfer_erc20_tool]", message);
    return { raw: { status: Status29.InvalidTransaction, error: message }, humanMessage: message };
  }
};
var TRANSFER_ERC20_TOOL = "transfer_erc20_tool";
var tool34 = (context) => ({
  method: TRANSFER_ERC20_TOOL,
  name: "Transfer ERC20",
  description: transferERC20Prompt(context),
  parameters: transferERC20Parameters(context),
  execute: transferERC20
});
var transfer_erc20_default = tool34;

// src/plugins/core-evm-plugin/tools/erc721/transfer-erc721.ts
import { Status as Status30 } from "@hashgraph/sdk";
var transferERC721Prompt = (context = {}) => {
  const contextSnippet = PromptGenerator.getContextSnippet(context);
  const fromAddressDesc = PromptGenerator.getAnyAddressParameterDescription("fromAddress", context);
  const usageInstructions = PromptGenerator.getParameterUsageInstructions();
  return `
${contextSnippet}

This tool will transfer an existing ERC721 token on Hedera. ERC721 is an EVM compatible non fungible token (NFT).

Parameters:
- contractId (str, required): The id of the ERC721 contract
- ${fromAddressDesc}
- toAddress (str, required): The address to which the token will be transferred. This can be the EVM address or the Hedera account id.
- tokenId (number, required): The ID of the transferred token
${PromptGenerator.getScheduledTransactionParamsDescription(context)}


${PromptGenerator.getParameterUsageInstructions()}

${usageInstructions}

Example:
"Transfer ERC721 token 0.0.6486793 with id 0 from 0xd94...580b to 0.0.6486793" transfers token ID 0 from the given EVM address to the given Hedera account.
`;
};
var postProcess35 = (response) => response?.scheduleId ? `Scheduled transfer of ERC721 successfully.
Transaction ID: ${response.transactionId}
Schedule ID: ${response.scheduleId.toString()}` : `ERC721 token transferred successfully.
    Transaction ID: ${response.transactionId}`;
var transferERC721 = async (client, context, params) => {
  const mirrorNode = getMirrornodeService(context.mirrornodeService, client.ledgerId);
  try {
    const normalisedParams = await HederaParameterNormaliser.normaliseTransferERC721Params(
      params,
      ERC721_TRANSFER_FUNCTION_ABI,
      ERC721_TRANSFER_FUNCTION_NAME,
      context,
      mirrorNode,
      client
    );
    const tx = HederaBuilder.executeTransaction(normalisedParams);
    return await handleTransaction(tx, client, context, postProcess35);
  } catch (error) {
    const message = "Failed to transfer ERC721" + (error instanceof Error ? `: ${error.message}` : "");
    console.error("[transfer_erc721_tool]", message);
    return { raw: { status: Status30.InvalidTransaction, error: message }, humanMessage: message };
  }
};
var TRANSFER_ERC721_TOOL = "transfer_erc721_tool";
var tool35 = (context) => ({
  method: TRANSFER_ERC721_TOOL,
  name: "Transfer ERC721",
  description: transferERC721Prompt(context),
  parameters: transferERC721Parameters(context),
  execute: transferERC721
});
var transfer_erc721_default = tool35;

// src/plugins/core-evm-plugin/tools/erc721/mint-erc721.ts
import { Status as Status31 } from "@hashgraph/sdk";
var mintERC721Prompt = (context = {}) => {
  const contextSnippet = PromptGenerator.getContextSnippet(context);
  const usageInstructions = PromptGenerator.getParameterUsageInstructions();
  const toAddressDesc = PromptGenerator.getAnyAddressParameterDescription("toAddress", context);
  return `
${contextSnippet}

This tool will mint a new ERC721 token on Hedera. ERC721 is an EVM compatible non fungible token (NFT).

Parameters:
- contractId (str, required): The id of the ERC721 contract
- ${toAddressDesc}
${PromptGenerator.getScheduledTransactionParamsDescription(context)}

${usageInstructions}

Example: "Mint ERC721 token 0.0.6486793 to 0xd94dc7f82f103757f715514e4a37186be6e4580b" means minting the ERC721 token with contract id 0.0.6486793 to the 0xd94dc7f82f103757f715514e4a37186be6e4580b EVM address.
Example: "Mint ERC721 token 0.0.6486793 to 0.0.6486793" means minting the ERC721 token with contract id 0.0.6486793 to the 0.0.6486793 Hedera account id.
`;
};
var postProcess36 = (response) => response?.scheduleId ? `Scheduled minting of ERC721 successfully.
Transaction ID: ${response.transactionId}
Schedule ID: ${response.scheduleId.toString()}` : `ERC721 token minted successfully.
    Transaction ID: ${response.transactionId}`;
var mintERC721 = async (client, context, params) => {
  try {
    const mirrorNode = getMirrornodeService(context.mirrornodeService, client.ledgerId);
    const normalisedParams = await HederaParameterNormaliser.normaliseMintERC721Params(
      params,
      ERC721_MINT_FUNCTION_ABI,
      ERC721_MINT_FUNCTION_NAME,
      context,
      mirrorNode,
      client
    );
    const tx = HederaBuilder.executeTransaction(normalisedParams);
    return await handleTransaction(tx, client, context, postProcess36);
  } catch (error) {
    const desc = "Failed to mint ERC721";
    const message = desc + (error instanceof Error ? `: ${error.message}` : "");
    console.error("[mint_erc721_tool]", message);
    return { raw: { status: Status31.InvalidTransaction, error: message }, humanMessage: message };
  }
};
var MINT_ERC721_TOOL = "mint_erc721_tool";
var tool36 = (context) => ({
  method: MINT_ERC721_TOOL,
  name: "Mint ERC721",
  description: mintERC721Prompt(context),
  parameters: mintERC721Parameters(context),
  execute: mintERC721
});
var mint_erc721_default = tool36;

// src/plugins/core-evm-plugin/tools/erc721/create-erc721.ts
import { Status as Status32, TransactionRecordQuery as TransactionRecordQuery2 } from "@hashgraph/sdk";
var createERC721Prompt = (context = {}) => `
${PromptGenerator.getContextSnippet(context)}

This tool creates an ERC721 token on Hedera by calling the BaseERC721Factory contract. ERC721 is an EVM compatible non fungible token (NFT).

Parameters:
- tokenName (str, required): The name of the token
- tokenSymbol (str, required): The symbol of the token
- baseURI (str, required): The base URI for token metadata
${PromptGenerator.getScheduledTransactionParamsDescription(context)}

${PromptGenerator.getParameterUsageInstructions()}
The contractId returned by the tool is the address of the ERC721 Factory contract, the address of the ERC721 token is the erc721Address returned by the tool.
`;
var getERC721Address = async (client, tx) => {
  const record = await new TransactionRecordQuery2().setTransactionId(tx.transactionId).execute(client);
  return "0x" + record.contractFunctionResult?.getAddress(0);
};
var postProcess37 = (erc721Address, response) => response?.scheduleId ? `Scheduled creation of ERC721 successfully.
Transaction ID: ${response.transactionId}
Schedule ID: ${response.scheduleId.toString()}` : `ERC721 token created successfully at address ${erc721Address ?? "unknown"}`;
var createERC721 = async (client, context, params) => {
  try {
    const factoryAddress = getERC721FactoryAddress(client.ledgerId);
    const txParams = await HederaParameterNormaliser.normaliseCreateERC721Params(
      params,
      factoryAddress,
      ERC721_FACTORY_ABI,
      "deployToken",
      context,
      client
    );
    const tx = HederaBuilder.executeTransaction(txParams);
    const result = await handleTransaction(tx, client, context);
    if (context.mode === "returnBytes" /* RETURN_BYTES */) return result;
    const raw = result.raw;
    const erc721Address = await getERC721Address(client, raw);
    const humanMessage = postProcess37(erc721Address, raw);
    return { ...result, erc721Address, humanMessage };
  } catch (error) {
    const message = "Failed to create ERC721 token" + (error instanceof Error ? `: ${error.message}` : "");
    console.error("[create_erc721_tool]", message);
    return {
      raw: { status: Status32.InvalidTransaction, error: message },
      humanMessage: message
    };
  }
};
var CREATE_ERC721_TOOL = "create_erc721_tool";
var tool37 = (context) => ({
  method: CREATE_ERC721_TOOL,
  name: "Create ERC721 Token",
  description: createERC721Prompt(context),
  parameters: createERC721Parameters(context),
  execute: createERC721
});
var create_erc721_default = tool37;

// src/plugins/core-evm-plugin/index.ts
var coreEVMPlugin = {
  name: "core-evm-plugin",
  version: "1.0.0",
  description: "A plugin for the Hedera EVM",
  tools: (context) => {
    return [
      create_erc20_default(context),
      transfer_erc20_default(context),
      transfer_erc721_default(context),
      mint_erc721_default(context),
      create_erc721_default(context)
    ];
  }
};
var coreEVMPluginToolNames = {
  TRANSFER_ERC721_TOOL,
  MINT_ERC721_TOOL,
  CREATE_ERC20_TOOL,
  TRANSFER_ERC20_TOOL,
  CREATE_ERC721_TOOL
};

// src/plugins/core-account-query-plugin/tools/queries/get-hbar-balance-query.ts
var getHbarBalanceQueryPrompt2 = (context = {}) => {
  const contextSnippet = PromptGenerator.getContextSnippet(context);
  const accountDesc = PromptGenerator.getAccountParameterDescription("accountId", context);
  const usageInstructions = PromptGenerator.getParameterUsageInstructions();
  return `
${contextSnippet}

This tool will return the HBAR balance for a given Hedera account.

Parameters:
- ${accountDesc}
${usageInstructions}
`;
};
var postProcess38 = (hbarBalance, accountId) => {
  return `Account ${accountId} has a balance of ${hbarBalance} HBAR`;
};
var getHbarBalanceQuery2 = async (client, context, params) => {
  try {
    const normalisedParams = HederaParameterNormaliser.normaliseHbarBalanceParams(
      params,
      context,
      client
    );
    const mirrornodeService = getMirrornodeService(context.mirrornodeService, client.ledgerId);
    const balance = await mirrornodeService.getAccountHbarBalance(
      normalisedParams.accountId
    );
    return {
      raw: { accountId: normalisedParams.accountId, hbarBalance: toHbar(balance).toString() },
      humanMessage: postProcess38(toHbar(balance).toString(), normalisedParams.accountId)
    };
  } catch (error) {
    const desc = "Failed to get HBAR balance";
    const message = desc + (error instanceof Error ? `: ${error.message}` : "");
    console.error("[get_hbar_balance_query_tool]", message);
    return { raw: { error: message }, humanMessage: message };
  }
};
var GET_HBAR_BALANCE_QUERY_TOOL2 = "get_hbar_balance_query_tool";
var tool38 = (context) => ({
  method: GET_HBAR_BALANCE_QUERY_TOOL2,
  name: "Get HBAR Balance",
  description: getHbarBalanceQueryPrompt2(context),
  parameters: accountBalanceQueryParameters(context),
  execute: getHbarBalanceQuery2
});
var get_hbar_balance_query_default2 = tool38;

// src/plugins/core-account-query-plugin/tools/queries/get-account-query.ts
import { Status as Status33 } from "@hashgraph/sdk";
var getAccountQueryPrompt2 = (context = {}) => {
  const contextSnippet = PromptGenerator.getContextSnippet(context);
  const usageInstructions = PromptGenerator.getParameterUsageInstructions();
  return `
${contextSnippet}

This tool will return the account information for a given Hedera account.

Parameters:
- accountId (str, required): The account ID to query
${usageInstructions}
`;
};
var postProcess39 = (account) => {
  return `Details for ${account.accountId}
Balance: ${account.balance.balance.toString()}
Public Key: ${account.accountPublicKey},
EVM address: ${account.evmAddress},
`;
};
var getAccountQuery2 = async (client, context, params) => {
  try {
    const mirrornodeService = getMirrornodeService(context.mirrornodeService, client.ledgerId);
    const account = await mirrornodeService.getAccount(params.accountId);
    return {
      raw: { accountId: params.accountId, account },
      humanMessage: postProcess39(account)
    };
  } catch (error) {
    const desc = "Failed to get account query";
    const message = desc + (error instanceof Error ? `: ${error.message}` : "");
    console.error("[get_account_query_tool]", message);
    return { raw: { status: Status33.InvalidTransaction, error: message }, humanMessage: message };
  }
};
var GET_ACCOUNT_QUERY_TOOL2 = "get_account_query_tool";
var tool39 = (context) => ({
  method: GET_ACCOUNT_QUERY_TOOL2,
  name: "Get Account Query",
  description: getAccountQueryPrompt2(context),
  parameters: accountQueryParameters(context),
  execute: getAccountQuery2
});
var get_account_query_default2 = tool39;

// src/plugins/core-account-query-plugin/tools/queries/get-account-token-balances-query.ts
var getAccountTokenBalancesQueryPrompt2 = (context = {}) => {
  const contextSnippet = PromptGenerator.getContextSnippet(context);
  const accountDesc = PromptGenerator.getAccountParameterDescription("accountId", context);
  const usageInstructions = PromptGenerator.getParameterUsageInstructions();
  return `
${contextSnippet}

This tool will return the token balances for a given Hedera account.

Parameters:
- ${accountDesc}
- tokenId (str, optional): The token ID to query for. If not provided, all token balances will be returned
${usageInstructions}
`;
};
var postProcess40 = (tokenBalances, accountId) => {
  if (tokenBalances.tokens.length === 0) {
    return `No token balances found for account ${accountId}`;
  }
  const balancesText = tokenBalances.tokens.map(
    (token) => ` Token: ${token.token_id}, Symbol: ${token.symbol}  Balance: ${token.balance}, Decimals: ${token.decimals}`
  ).join("\n");
  return `Details for ${accountId}
--- Token Balances ---
${balancesText}`;
};
var getAccountTokenBalancesQuery2 = async (client, context, params) => {
  try {
    const normalisedParams = HederaParameterNormaliser.normaliseAccountTokenBalancesParams(
      params,
      context,
      client
    );
    const mirrornodeService = getMirrornodeService(context.mirrornodeService, client.ledgerId);
    const tokenBalances = await mirrornodeService.getAccountTokenBalances(
      normalisedParams.accountId,
      normalisedParams.tokenId
    );
    return {
      raw: { accountId: normalisedParams.accountId, tokenBalances },
      humanMessage: postProcess40(tokenBalances, normalisedParams.accountId)
    };
  } catch (error) {
    const desc = "Failed to get account token balances";
    const message = desc + (error instanceof Error ? `: ${error.message}` : "");
    console.error("[get_account_token_balances_query_tool]", message);
    return { raw: { error: message }, humanMessage: message };
  }
};
var GET_ACCOUNT_TOKEN_BALANCES_QUERY_TOOL2 = "get_account_token_balances_query_tool";
var tool40 = (context) => ({
  method: GET_ACCOUNT_TOKEN_BALANCES_QUERY_TOOL2,
  name: "Get Account Token Balances",
  description: getAccountTokenBalancesQueryPrompt2(context),
  parameters: accountTokenBalancesQueryParameters(context),
  execute: getAccountTokenBalancesQuery2
});
var get_account_token_balances_query_default2 = tool40;

// src/plugins/core-account-query-plugin/index.ts
var coreAccountQueryPlugin = {
  name: "core-account-query-plugin",
  version: "1.0.0",
  description: "A plugin for Hedera Account Service queries",
  tools: (context) => {
    return [
      get_hbar_balance_query_default2(context),
      get_account_query_default2(context),
      get_account_token_balances_query_default2(context)
    ];
  }
};
var coreAccountQueryPluginToolNames = {
  GET_HBAR_BALANCE_QUERY_TOOL: GET_HBAR_BALANCE_QUERY_TOOL2,
  GET_ACCOUNT_QUERY_TOOL: GET_ACCOUNT_QUERY_TOOL2,
  GET_ACCOUNT_TOKEN_BALANCES_QUERY_TOOL: GET_ACCOUNT_TOKEN_BALANCES_QUERY_TOOL2
};

// src/plugins/core-token-query-plugin/tools/queries/get-token-info-query.ts
var getTokenInfoQueryPrompt2 = (context = {}) => {
  const contextSnippet = PromptGenerator.getContextSnippet(context);
  const usageInstructions = PromptGenerator.getParameterUsageInstructions();
  return `
${contextSnippet}

This tool will return the information for a given Hedera token. Make sure to return token symbol.

Parameters:
- tokenId (str): The token ID to query for.
${usageInstructions}
`;
};
var postProcess41 = (tokenInfo) => {
  const formatSupply = (supply) => {
    if (!supply) return "N/A";
    const decimals = Number(tokenInfo.decimals || "0");
    const amount = Number(supply);
    if (isNaN(amount)) return supply;
    return (amount / 10 ** decimals).toLocaleString();
  };
  const formatKey = (key) => {
    if (!key) return "Not Set";
    return key._type ? `${key.key}` : "Present";
  };
  const supplyType = tokenInfo.supply_type === "INFINITE" ? "Infinite" : "Finite";
  const freezeStatus = tokenInfo.freeze_default ? "Frozen" : "Active";
  return `Here are the details for token **${tokenInfo.token_id}**:

- **Token Name**: ${tokenInfo.name}
- **Token Symbol**: ${tokenInfo.symbol}
- **Token Type**: ${tokenInfo.type || "N/A"}
- **Decimals**: ${tokenInfo.decimals}
- **Max Supply**: ${formatSupply(tokenInfo.max_supply)}
- **Current Supply**: ${formatSupply(tokenInfo.total_supply)}
- **Supply Type**: ${supplyType}
- **Treasury Account ID**: ${tokenInfo.treasury_account_id || "N/A"}
- **Status (Deleted/Active)**: ${tokenInfo.deleted ? "Deleted" : "Active"}
- **Status (Frozen/Active)**: ${freezeStatus}

**Keys**:
- Admin Key: ${formatKey(tokenInfo.admin_key)}
- Supply Key: ${formatKey(tokenInfo.supply_key)}
- Wipe Key: ${formatKey(tokenInfo.wipe_key)}
- KYC Key: ${formatKey(tokenInfo.kyc_key)}
- Freeze Key: ${formatKey(tokenInfo.freeze_key)}
- Fee Schedule Key: ${formatKey(tokenInfo.fee_schedule_key)}
- Pause Key: ${formatKey(tokenInfo.pause_key)}
- Metadata Key: ${formatKey(tokenInfo.metadata_key)}

${tokenInfo.memo ? `**Memo**: ${tokenInfo.memo}` : ""}
`;
};
var getTokenInfoQuery2 = async (client, context, params) => {
  try {
    const mirrornodeService = getMirrornodeService(context.mirrornodeService, client.ledgerId);
    const tokenInfo = {
      ...await mirrornodeService.getTokenInfo(params.tokenId),
      token_id: params.tokenId
    };
    return {
      raw: { tokenId: params.tokenId, tokenInfo },
      humanMessage: postProcess41(tokenInfo)
    };
  } catch (error) {
    const desc = "Failed to get token info";
    const message = desc + (error instanceof Error ? `: ${error.message}` : "");
    console.error("[get_token_info_query_tool]", message);
    return { raw: { error: message }, humanMessage: message };
  }
};
var GET_TOKEN_INFO_QUERY_TOOL2 = "get_token_info_query_tool";
var tool41 = (context) => ({
  method: GET_TOKEN_INFO_QUERY_TOOL2,
  name: "Get Token Info",
  description: getTokenInfoQueryPrompt2(context),
  parameters: tokenInfoQueryParameters(context),
  execute: getTokenInfoQuery2
});
var get_token_info_query_default2 = tool41;

// src/plugins/core-token-query-plugin/tools/queries/get-pending-airdrop-query.ts
var getPendingAirdropQueryPrompt = (context = {}) => {
  const contextSnippet = PromptGenerator.getContextSnippet(context);
  const accountDesc = PromptGenerator.getAccountParameterDescription("accountId", context);
  const usageInstructions = PromptGenerator.getParameterUsageInstructions();
  return `
${contextSnippet}

This tool will return pending airdrops for a given Hedera account.

Parameters:
- ${accountDesc}
${usageInstructions}
`;
};
var formatAirdrop = (airdrop, index) => {
  const token = airdrop.token_id ?? "N/A";
  const amount = airdrop.amount ?? 0;
  const serial = airdrop.serial_number ?? "N/A";
  const sender = airdrop.sender_id ?? "N/A";
  const receiver = airdrop.receiver_id ?? "N/A";
  const fromTs = airdrop.timestamp?.from ?? "N/A";
  const toTs = airdrop.timestamp?.to ?? "N/A";
  return `#${index + 1} Token: ${token}, Amount: ${amount}, Serial: ${serial}, Sender: ${sender}, Receiver: ${receiver}, Timestamp: ${fromTs}${toTs ? ` \u2192 ${toTs}` : ""}`;
};
var postProcess42 = (accountId, response) => {
  const count = response.airdrops?.length ?? 0;
  if (count === 0) {
    return `No pending airdrops found for account ${accountId}`;
  }
  const details = response.airdrops.map(formatAirdrop).join("\n");
  return `Here are the pending airdrops for account **${accountId}** (total: ${count}):

${details}`;
};
var getPendingAirdropQuery = async (client, context, params) => {
  try {
    const accountId = params.accountId ?? AccountResolver.getDefaultAccount(context, client);
    if (!accountId) throw new Error("Account ID is required and was not provided");
    const mirrornodeService = getMirrornodeService(context.mirrornodeService, client.ledgerId);
    const response = await mirrornodeService.getPendingAirdrops(accountId);
    return {
      raw: { accountId, pendingAirdrops: response },
      humanMessage: postProcess42(accountId, response)
    };
  } catch (error) {
    const desc = "Failed to get pending airdrops";
    const message = desc + (error instanceof Error ? `: ${error.message}` : "");
    console.error("[get_pending_airdrop_query_tool]", message);
    return { raw: { error: message }, humanMessage: message };
  }
};
var GET_PENDING_AIRDROP_TOOL = "get_pending_airdrop_tool";
var tool42 = (context) => ({
  method: GET_PENDING_AIRDROP_TOOL,
  name: "Get Pending Airdrops",
  description: getPendingAirdropQueryPrompt(context),
  parameters: pendingAirdropQueryParameters(context),
  execute: getPendingAirdropQuery
});
var get_pending_airdrop_query_default = tool42;

// src/plugins/core-token-query-plugin/index.ts
var coreTokenQueryPlugin = {
  name: "core-token-query-plugin",
  version: "1.0.0",
  description: "A plugin for Hedera Token Service queries",
  tools: (context) => {
    return [get_token_info_query_default2(context), get_pending_airdrop_query_default(context)];
  }
};
var coreTokenQueryPluginToolNames = {
  GET_TOKEN_INFO_QUERY_TOOL: GET_TOKEN_INFO_QUERY_TOOL2,
  GET_PENDING_AIRDROP_TOOL
};

// src/plugins/core-consensus-query-plugin/tools/queries/get-topic-messages-query.ts
var getTopicMessagesQueryPrompt2 = (context = {}) => {
  const contextSnippet = PromptGenerator.getContextSnippet(context);
  const usageInstructions = PromptGenerator.getParameterUsageInstructions();
  return `
${contextSnippet}

This tool will return the messages for a given Hedera topic.

Parameters:
- topicId (str, required): The topic ID to query
- startTime (datetime, optional): The start datetime to query. If set, the messages will be returned after this datetime
- endTime (datetime, optional): The end datetime to query. If set, the messages will be returned before this datetime
- limit (int, optional): The limit of messages to query. If set, the number of messages to return
${usageInstructions}
`;
};
var postProcess43 = (messages, topicId) => {
  if (messages.length === 0) {
    return `No messages found for topic ${topicId}.`;
  }
  const messagesText = messages.map(
    (message) => `${Buffer.from(message.message, "base64").toString("utf-8")} - posted at: ${message.consensus_timestamp}
`
  );
  return `Messages for topic ${topicId}:
  --- Messages ---
  ${messagesText}
  `;
};
var getTopicMessagesQueryParams2 = (params) => {
  return {
    topicId: params.topicId,
    lowerTimestamp: params.startTime ? `${Math.floor(new Date(params.startTime).getTime() / 1e3)}.000000000` : "",
    upperTimestamp: params.endTime ? `${Math.floor(new Date(params.endTime).getTime() / 1e3)}.000000000` : "",
    limit: params.limit || 100
  };
};
var convertMessagesFromBase64ToString2 = (messages) => {
  return messages.map((message) => {
    return {
      ...message,
      message: Buffer.from(message.message, "base64").toString("utf-8")
    };
  });
};
var getTopicMessagesQuery2 = async (client, context, params) => {
  try {
    const mirrornodeService = getMirrornodeService(context.mirrornodeService, client.ledgerId);
    const messages = await mirrornodeService.getTopicMessages(getTopicMessagesQueryParams2(params));
    return {
      raw: {
        topicId: messages.topicId,
        messages: convertMessagesFromBase64ToString2(messages.messages)
      },
      humanMessage: postProcess43(messages.messages, params.topicId)
    };
  } catch (error) {
    const desc = "Failed to get topic messages";
    const message = desc + (error instanceof Error ? `: ${error.message}` : "");
    console.error("[get_topic_messages_query_tool]", message);
    return { raw: { error: message }, humanMessage: message };
  }
};
var GET_TOPIC_MESSAGES_QUERY_TOOL2 = "get_topic_messages_query_tool";
var tool43 = (context) => ({
  method: GET_TOPIC_MESSAGES_QUERY_TOOL2,
  name: "Get Topic Messages",
  description: getTopicMessagesQueryPrompt2(context),
  parameters: topicMessagesQueryParameters(context),
  execute: getTopicMessagesQuery2
});
var get_topic_messages_query_default2 = tool43;

// src/plugins/core-consensus-query-plugin/tools/queries/get-topic-info-query.ts
var getTopicInfoQueryPrompt = (context = {}) => {
  const contextSnippet = PromptGenerator.getContextSnippet(context);
  const usageInstructions = PromptGenerator.getParameterUsageInstructions();
  return `
${contextSnippet}

This tool will return the information for a given Hedera topic (HCS).

Parameters:
- topicId (str): The topic ID to query for.
${usageInstructions}
`;
};
var postProcess44 = (topic) => {
  const formatKey = (key) => {
    if (!key) return "Not Set";
    return key._type ? key.key || "Present" : "Present";
  };
  const formatTimestamp = (ts) => {
    if (!ts) return "N/A";
    const [seconds] = ts.split(".");
    const date = new Date(Number(seconds) * 1e3);
    return date.toISOString();
  };
  return `Here are the details for topic **${topic.topic_id || "N/A"}**:

- **Memo**: ${topic.memo || "N/A"}
- **Deleted**: ${topic.deleted ? "Yes" : "No"}
- **Sequence Number**: ${topic.sequence_number ?? "N/A"}

**Timestamps**:
- Created: ${formatTimestamp(topic.created_timestamp)}

**Entity IDs**:
- Auto Renew Account: ${topic.auto_renew_account || "N/A"}
- Auto Renew Period: ${topic.auto_renew_period ?? "N/A"}

**Keys**:
- Admin Key: ${formatKey(topic.admin_key)}
- Submit Key: ${formatKey(topic.submit_key)}
`;
};
var getTopicInfoQuery = async (client, context, params) => {
  try {
    const mirrornodeService = getMirrornodeService(context.mirrornodeService, client.ledgerId);
    const topicInfo = {
      ...await mirrornodeService.getTopicInfo(params.topicId),
      topic_id: params.topicId
    };
    return {
      raw: { topicId: params.topicId, topicInfo },
      humanMessage: postProcess44(topicInfo)
    };
  } catch (error) {
    const desc = "Failed to get topic info";
    const message = desc + (error instanceof Error ? `: ${error.message}` : "");
    console.error("[get_topic_info_query_tool]", message);
    return { raw: { error: message }, humanMessage: message };
  }
};
var GET_TOPIC_INFO_QUERY_TOOL = "get_topic_info_query_tool";
var tool44 = (context) => ({
  method: GET_TOPIC_INFO_QUERY_TOOL,
  name: "Get Topic Info",
  description: getTopicInfoQueryPrompt(context),
  parameters: getTopicInfoParameters(context),
  execute: getTopicInfoQuery
});
var get_topic_info_query_default = tool44;

// src/plugins/core-consensus-query-plugin/index.ts
var coreConsensusQueryPlugin = {
  name: "core-consensus-query-plugin",
  version: "1.0.0",
  description: "A plugin for Hedera Consensus Service queries",
  tools: (context) => {
    return [get_topic_messages_query_default2(context), get_topic_info_query_default(context)];
  }
};
var coreConsensusQueryPluginToolNames = {
  GET_TOPIC_MESSAGES_QUERY_TOOL: GET_TOPIC_MESSAGES_QUERY_TOOL2,
  GET_TOPIC_INFO_QUERY_TOOL
};

// src/plugins/core-evm-query-plugin/tools/queries/get-contract-info-query.ts
var getContractInfoQueryPrompt = (context = {}) => {
  const contextSnippet = PromptGenerator.getContextSnippet(context);
  const usageInstructions = PromptGenerator.getParameterUsageInstructions();
  return `
${contextSnippet}

This tool will return the information for a given Hedera contract.

Parameters:
- contractId (str): The contract ID to query for.
${usageInstructions}
`;
};
var postProcess45 = (contract) => {
  const formatKey = (key) => {
    if (!key) return "Not Set";
    return key._type ? key.key || "Present" : "Present";
  };
  const formatTimestamp = (ts) => {
    if (!ts) return "N/A";
    const [seconds, nanos] = ts.split(".");
    const date = new Date(Number(seconds) * 1e3);
    return date.toISOString() + (nanos ? `.${nanos}` : "");
  };
  return `Here are the details for contract **${contract.contract_id || "N/A"}**:

- **Memo**: ${contract.memo || "N/A"}
- **Deleted**: ${contract.deleted ? "Yes" : "No"}
- **Permanent Removal**: ${contract.permanent_removal ? "Yes" : "No"}
- **Nonce**: ${contract.nonce ?? "N/A"}

**Timestamps**:
- Created: ${formatTimestamp(contract.created_timestamp)}
- Expiration: ${formatTimestamp(contract.expiration_timestamp)}
- Valid From: ${contract.timestamp?.from || "N/A"}
- Valid To: ${contract.timestamp?.to || "N/A"}

**Entity IDs**:
- Auto Renew Account: ${contract.auto_renew_account || "N/A"}
- File ID: ${contract.file_id || "N/A"}
- Obtainer ID: ${contract.obtainer_id || "N/A"}
- Proxy Account ID: ${contract.proxy_account_id || "N/A"}

**Keys**:
- Admin Key: ${formatKey(contract.admin_key)}

**EVM**:
- Address: ${contract.evm_address || "N/A"}
`;
};
var getContractInfoQuery = async (client, context, params) => {
  try {
    const mirrornodeService = getMirrornodeService(context.mirrornodeService, client.ledgerId);
    const contractInfo = await mirrornodeService.getContractInfo(params.contractId);
    return {
      raw: { contractId: contractInfo.contract_id, contractInfo },
      humanMessage: postProcess45(contractInfo)
    };
  } catch (error) {
    const desc = "Failed to get contract info";
    const message = desc + (error instanceof Error ? `: ${error.message}` : "");
    console.error("[get_contract_info_query_tool]", message);
    return { raw: { error: message }, humanMessage: message };
  }
};
var GET_CONTRACT_INFO_QUERY_TOOL = "get_contract_info_query_tool";
var tool45 = (context) => ({
  method: GET_CONTRACT_INFO_QUERY_TOOL,
  name: "Get Contract Info",
  description: getContractInfoQueryPrompt(context),
  parameters: contractInfoQueryParameters(context),
  execute: getContractInfoQuery
});
var get_contract_info_query_default = tool45;

// src/plugins/core-evm-query-plugin/index.ts
var coreEVMQueryPlugin = {
  name: "core-evm-query-plugin",
  version: "1.0.0",
  description: "A plugin for Hedera EVM Service queries",
  tools: (context) => {
    return [get_contract_info_query_default(context)];
  }
};
var coreEVMQueryPluginToolNames = {
  GET_CONTRACT_INFO_QUERY_TOOL
};

// src/plugins/core-transactions-query-plugin/tools/queries/get-transaction-record-query.ts
var getTransactionRecordQueryPrompt = (context = {}) => {
  const contextSnippet = PromptGenerator.getContextSnippet(context);
  const usageInstructions = PromptGenerator.getParameterUsageInstructions();
  return `
${contextSnippet}

This tool will return the transaction record for a given Hedera transaction ID.

Parameters:
- transactionId (str, required): The transaction ID to fetch record for. Should be in format \\"shard.realm.num-sss-nnn\\" format where sss are seconds and nnn are nanoseconds
- nonce (number, optional): Optional nonce value for the transaction
${usageInstructions}

Additional information:
If user provides transaction ID in format 0.0.4177806@1755169980.051721264, parse it to 0.0.4177806-1755169980-051721264 and use it as transaction ID. Do not remove the staring zeros.
`;
};
var postProcess46 = (transactionRecord, transactionId) => {
  if (!transactionRecord.transactions || transactionRecord.transactions.length === 0) {
    return `No transaction details found for transaction ID: ${transactionId}`;
  }
  const results = transactionRecord.transactions.map((tx, index) => {
    let transfersInfo = "";
    if (tx.transfers && tx.transfers.length > 0) {
      transfersInfo = "\nTransfers:\n" + tx.transfers.map(
        (transfer) => `  Account: ${transfer.account}, Amount: ${toDisplayUnit(transfer.amount, 8)}\u210F`
      ).join("\n");
    }
    const transactionHeader = transactionRecord.transactions.length > 1 ? `Transaction ${index + 1} Details for ${transactionId}` : `Transaction Details for ${transactionId}`;
    return `${transactionHeader}
Status: ${tx.result}
Consensus Timestamp: ${tx.consensus_timestamp}
Transaction Hash: ${tx.transaction_hash}
Transaction Fee: ${tx.charged_tx_fee}
Type: ${tx.name}
Entity ID: ${tx.entity_id}${transfersInfo}`;
  });
  return results.join("\n\n" + "=".repeat(50) + "\n\n");
};
var getTransactionRecordQuery = async (client, context, params) => {
  try {
    const mirrornodeService = getMirrornodeService(context.mirrornodeService, client.ledgerId);
    const normalisedParams = HederaParameterNormaliser.normaliseGetTransactionRecordParams(
      params,
      context
    );
    const transactionRecord = await mirrornodeService.getTransactionRecord(
      normalisedParams.transactionId,
      normalisedParams.nonce
    );
    return {
      raw: { transactionId: params.transactionId, transactionRecord },
      humanMessage: postProcess46(transactionRecord, params.transactionId)
    };
  } catch (error) {
    const desc = "Failed to get transaction record";
    const message = desc + (error instanceof Error ? `: ${error.message}` : "");
    console.error("[get_transaction_record_query_tool]", message);
    return { raw: { error: message }, humanMessage: message };
  }
};
var GET_TRANSACTION_RECORD_QUERY_TOOL = "get_transaction_record_query_tool";
var tool46 = (context) => ({
  method: GET_TRANSACTION_RECORD_QUERY_TOOL,
  name: "Get Transaction Record Query",
  description: getTransactionRecordQueryPrompt(context),
  parameters: transactionRecordQueryParameters(context),
  execute: getTransactionRecordQuery
});
var get_transaction_record_query_default = tool46;

// src/plugins/core-transactions-query-plugin/index.ts
var coreTransactionQueryPlugin = {
  name: "core-transaction-query-plugin",
  version: "1.0.0",
  description: "A plugin for Hedera Transactions queries",
  tools: (context) => {
    return [get_transaction_record_query_default(context)];
  }
};
var coreTransactionQueryPluginToolNames = {
  GET_TRANSACTION_RECORD_QUERY_TOOL
};

// src/plugins/index.ts
var coreHTSPlugin = coreTokenPlugin;
var coreHTSPluginToolNames = coreTokenPluginToolNames;
var coreSCSPlugin = coreEVMPlugin;
var coreSCSPluginToolNames = coreEVMPluginToolNames;

// src/shared/plugin.ts
var CORE_PLUGINS = [
  coreAccountPlugin,
  coreTokenPlugin,
  coreConsensusPlugin,
  coreEVMPlugin,
  coreAccountQueryPlugin,
  coreTokenQueryPlugin,
  coreConsensusQueryPlugin
];
var PluginRegistry = class {
  plugins = /* @__PURE__ */ new Map();
  register(plugin) {
    if (this.plugins.has(plugin.name)) {
      console.warn(`Plugin "${plugin.name}" is already registered. Overwriting.`);
    }
    this.plugins.set(plugin.name, plugin);
  }
  getPlugins() {
    return Array.from(this.plugins.values());
  }
  loadCorePlugins(context) {
    const pluginTools = [];
    for (const plugin of CORE_PLUGINS) {
      try {
        const tools = plugin.tools(context);
        pluginTools.push(...tools);
      } catch (error) {
        console.error(`Error loading tools from plugin "${plugin.name}":`, error);
      }
    }
    return pluginTools;
  }
  loadPlugins(context) {
    const pluginTools = [];
    for (const plugin of this.plugins.values()) {
      try {
        const tools = plugin.tools(context);
        pluginTools.push(...tools);
      } catch (error) {
        console.error(`Error loading tools from plugin "${plugin.name}":`, error);
      }
    }
    return pluginTools;
  }
  getTools(context) {
    if (this.plugins.size === 0) {
      return this.loadCorePlugins(context);
    } else {
      return this.loadPlugins(context);
    }
  }
  clear() {
    this.plugins.clear();
  }
};

// src/langchain/tool.ts
import { StructuredTool } from "@langchain/core/tools";
var HederaAgentKitTool = class extends StructuredTool {
  hederaAPI;
  method;
  name;
  description;
  schema;
  constructor(HederaAgentKitAPI, method, description, schema) {
    super();
    this.hederaAPI = HederaAgentKitAPI;
    this.method = method;
    this.name = method;
    this.description = description;
    this.schema = schema;
  }
  _call(arg, _runManager, _parentConfig) {
    return this.hederaAPI.run(this.method, arg);
  }
};
var tool_default = HederaAgentKitTool;

// src/shared/tool-discovery.ts
var ToolDiscovery = class _ToolDiscovery {
  pluginRegistry = new PluginRegistry();
  constructor(plugins = []) {
    plugins.forEach((plugin) => this.pluginRegistry.register(plugin));
  }
  getAllTools(context, configuration) {
    const pluginTools = this.pluginRegistry.getTools(context);
    const allTools = [];
    const allToolNames = /* @__PURE__ */ new Set();
    pluginTools.forEach((pluginTool) => {
      if (!allToolNames.has(pluginTool.method)) {
        allTools.push(pluginTool);
        allToolNames.add(pluginTool.method);
      } else {
        console.warn(
          `Plugin tool "${pluginTool.method}" conflicts with core tool. Using core tool.`
        );
      }
    });
    if (configuration?.tools && configuration.tools.length > 0) {
      return allTools.filter((tool48) => configuration.tools.includes(tool48.method));
    }
    return allTools;
  }
  static createFromConfiguration(configuration) {
    return new _ToolDiscovery(configuration.plugins || []);
  }
};

// src/langchain/toolkit.ts
var HederaLangchainToolkit = class {
  _hederaAgentKit;
  tools;
  constructor({ client, configuration }) {
    const context = configuration.context || {};
    const toolDiscovery = ToolDiscovery.createFromConfiguration(configuration);
    const allTools = toolDiscovery.getAllTools(context, configuration);
    this._hederaAgentKit = new api_default(client, configuration.context, allTools);
    this.tools = allTools.map(
      (tool48) => new tool_default(
        this._hederaAgentKit,
        tool48.method,
        tool48.description,
        tool48.parameters
      )
    );
  }
  getTools() {
    return this.tools;
  }
  getHederaAgentKitAPI() {
    return this._hederaAgentKit;
  }
};
var toolkit_default = HederaLangchainToolkit;

// src/modelcontextprotocol/toolkit.ts
import { McpServer } from "@modelcontextprotocol/sdk/server/mcp.js";
var HederaMCPToolkit = class extends McpServer {
  _hederaAgentKit;
  constructor({ client, configuration }) {
    super({
      name: "Hedera Agent Kit",
      version: "0.1.0",
      configuration: {
        ...configuration,
        context: {
          ...configuration.context,
          mode: "modelcontextprotocol"
        }
      }
    });
    const context = configuration.context || {};
    const toolDiscovery = ToolDiscovery.createFromConfiguration(configuration);
    const allTools = toolDiscovery.getAllTools(context, configuration);
    this._hederaAgentKit = new api_default(client, configuration.context, allTools);
    allTools.map((tool48) => {
      this.tool(
        tool48.method,
        tool48.description,
        tool48.parameters.shape,
        async (arg, _extra) => {
          const result = await this._hederaAgentKit.run(tool48.method, arg);
          return {
            content: [
              {
                type: "text",
                text: String(result)
              }
            ]
          };
        }
      );
    });
  }
};
var toolkit_default2 = HederaMCPToolkit;

// src/ai-sdk/tool.ts
import { tool as tool47 } from "ai";
function HederaAgentKitTool2(hederaAPI, method, description, schema) {
  return tool47({
    description,
    parameters: schema,
    execute: (arg) => {
      return hederaAPI.run(method, arg);
    }
  });
}

// src/ai-sdk/toolkit.ts
var HederaAIToolkit = class {
  _hedera;
  tools;
  constructor({ client, configuration }) {
    const context = configuration.context || {};
    const toolDiscovery = ToolDiscovery.createFromConfiguration(configuration);
    const allTools = toolDiscovery.getAllTools(context, configuration);
    this._hedera = new api_default(client, configuration.context, allTools);
    this.tools = {};
    allTools.forEach((tool48) => {
      this.tools[tool48.method] = HederaAgentKitTool2(
        this._hedera,
        tool48.method,
        tool48.description,
        tool48.parameters
      );
    });
  }
  middleware() {
    return {
      wrapGenerate: async ({ doGenerate }) => {
        return doGenerate();
      },
      wrapStream: async ({ doStream }) => {
        return doStream();
      }
    };
  }
  getTools() {
    return this.tools;
  }
};
var toolkit_default3 = HederaAIToolkit;

// src/elizaos/tool.ts
import {
  composePromptFromState,
  logger,
  ModelType
} from "@elizaos/core";

// src/elizaos/utils/extraction.ts
import { zodToJsonSchema } from "zod-to-json-schema";
function generateExtractionTemplate(tool48) {
  const zodSchema = tool48.parameters;
  const description = tool48.description;
  const actionName = tool48.name;
  const toolParamsJSONSchema = zodToJsonSchema(zodSchema, actionName);
  return `Given the recent messages and Hedera wallet information below:
{{recentMessages}}
{{hederaAccountDetails}}

Extract the following parameters based on the tool/action description and json schema below:

### Tool/action description:
${description}

\u26A0\uFE0F Do **not** assume values or apply defaults. Do **not** set a field unless it is clearly specified in the latest user input.
\u26A0\uFE0F **IMPORTANT**: Always ensure numeric values are provided as NUMBERS WITHOUT QUOTES in the JSON response.
\u26A0\uFE0F **IMPORTANT**: Always ensure string values are provided as QUOTED STRINGS in the JSON response.
\u26A0\uFE0F **CRITICAL**: Enum values must be provided as QUOTED STRINGS (e.g., "finite", not finite).
\u26A0\uFE0F **CRITICAL**: The returned JSON must be a valid JSON object in markdown format. Don not include comments inside it. If no params is passed return an empty JSON object.

---

### Response format:
Respond with a JSON markdown block including the fields that were explicitly mentioned in the most recent user message.

Response JSON schema:
${JSON.stringify(toolParamsJSONSchema, null, 2)}

---

Numeric values should be numbers without quotes. Enum values must be quoted strings.`;
}

// src/elizaos/utils/parser.ts
var jsonBlockPattern = /```(?:json)?\s*([\s\S]*?)```/;
function customParseJSONObjectFromText(text) {
  if (!text) return null;
  let jsonData = null;
  const jsonBlockMatch = text.match(jsonBlockPattern);
  try {
    if (jsonBlockMatch) {
      const jsonContent = jsonBlockMatch[1].trim().replace(/[\u0000-\u001F\u007F-\u009F]/g, "");
      jsonData = JSON.parse(jsonContent);
    } else {
      try {
        jsonData = JSON.parse(text.trim());
      } catch {
        jsonData = JSON.parse(customNormalizeJsonString(text.trim()));
      }
    }
  } catch (error) {
    console.warn("Could not parse text as JSON:", error);
    return null;
  }
  if (jsonData && typeof jsonData === "object") {
    return jsonData;
  }
  console.warn("Parsed result is not a valid object or array");
  return null;
}
function customNormalizeJsonString(str) {
  if (!str) return str;
  str = str.replace(/\{\s+/, "{").replace(/\s+\}/, "}").trim();
  str = str.replace(/(\s*)(\w+)(\s*):(\s*)/g, '$1"$2"$3:$4');
  str = str.replace(/"([^"]+)"\s*:\s*'([^']*)'/g, (_, key, value) => `"${key}": "${value}"`);
  str = str.replace(/"([^"]+)"\s*:\s*([^",\{\[\]\}0-9][^",\{\[\]\}\s]*)/g, (match, key, value) => {
    if (value === "true" || value === "false" || value === "null") {
      return `"${key}": ${value}`;
    }
    if (!isNaN(Number(value))) {
      return `"${key}": ${value}`;
    }
    return `"${key}": "${value}"`;
  });
  return str;
}

// src/elizaos/tool.ts
var HederaAgentKitTool3 = class {
  description;
  handler;
  similes;
  examples;
  name;
  validate;
  constructor(client, context, tool48) {
    const parameterSchema = tool48.parameters;
    this.description = tool48.description;
    this.name = tool48.method.toUpperCase();
    this.similes = [tool48.method.toUpperCase()];
    this.validate = async (_runtime, _message) => true;
    this.handler = async (runtime, _message, state, _options, callback) => {
      logger.log(`Running ${tool48.method} handler...`);
      if (!state) {
        throw new Error("State is undefined");
      }
      const prompt = composePromptFromState({
        state,
        template: generateExtractionTemplate(tool48)
      });
      logger.debug(`prompt: ${prompt}`);
      const modelOutput = await runtime.useModel(ModelType.TEXT_LARGE, { prompt });
      logger.debug(`Model extraction output: ${modelOutput}`);
      const parsedParams = customParseJSONObjectFromText(modelOutput);
      logger.debug("Parsed params object", parsedParams);
      const validation = parameterSchema.safeParse(parsedParams);
      logger.debug("Validated params:" + JSON.stringify(validation, null, 2));
      if (!validation.success) {
        const promptText = `given the recent messages {{recent_messages}}, 
        tool description: ${tool48.description}
        and the error message: ${validation.error.format()}
        generate a comprehensive message to the user about missing params
        `;
        const modelOutput2 = await runtime.useModel(ModelType.TEXT_LARGE, { promptText });
        if (callback) {
          await callback({
            text: modelOutput2,
            content: { error: validation.error.format() }
          });
        }
        return {
          success: false,
          text: modelOutput2,
          error: validation.error.toString()
        };
      }
      try {
        const result = await tool48.execute(client, context, validation.data);
        const responseText = result.humanMessage;
        if (callback) {
          await callback({
            text: responseText,
            content: result
          });
        }
        return { success: true, text: responseText };
      } catch (err) {
        const message = err instanceof Error ? err.message : "Unknown error";
        logger.error(`Error running tool ${tool48.method}:`, err);
        if (callback) {
          await callback({
            text: `Execution failed: ${message}`,
            content: { error: message }
          });
        }
        return { success: false, text: `Execution failed: ${message}`, error: message };
      }
    };
  }
};
var tool_default2 = HederaAgentKitTool3;

// src/elizaos/toolkit.ts
var HederaElizaOSToolkit = class {
  tools;
  client;
  context;
  constructor({ client, configuration }) {
    this.client = client;
    this.context = configuration.context || {};
    const toolDiscovery = ToolDiscovery.createFromConfiguration(configuration);
    const allTools = toolDiscovery.getAllTools(this.context, configuration);
    this.tools = allTools.map((tool48) => new tool_default2(this.client, this.context, tool48));
  }
  /**
   * Maps hedera-agent-kit tools and returns ElizaOS compatible actions
   */
  getTools() {
    return this.tools;
  }
};
export {
  AccountResolver,
  AgentMode,
  ERC20_FACTORY_ABI,
  ERC20_FACTORY_ADDRESSES,
  ERC20_TRANSFER_FUNCTION_ABI,
  ERC20_TRANSFER_FUNCTION_NAME,
  ERC721_FACTORY_ABI,
  ERC721_FACTORY_ADDRESSES,
  ERC721_MINT_FUNCTION_ABI,
  ERC721_MINT_FUNCTION_NAME,
  ERC721_TRANSFER_FUNCTION_ABI,
  ERC721_TRANSFER_FUNCTION_NAME,
  ExecuteStrategy,
  toolkit_default3 as HederaAIToolkit,
  HederaElizaOSToolkit,
  toolkit_default as HederaLangchainToolkit,
  toolkit_default2 as HederaMCPToolkit,
  PluginRegistry,
  PromptGenerator,
  coreAccountPlugin,
  coreAccountPluginToolNames,
  coreAccountQueryPlugin,
  coreAccountQueryPluginToolNames,
  coreConsensusPlugin,
  coreConsensusPluginToolNames,
  coreConsensusQueryPlugin,
  coreConsensusQueryPluginToolNames,
  coreEVMPlugin,
  coreEVMPluginToolNames,
  coreEVMQueryPlugin,
  coreEVMQueryPluginToolNames,
  coreHTSPlugin,
  coreHTSPluginToolNames,
  coreMiscQueriesPlugin,
  coreMiscQueriesPluginsToolNames,
  coreQueriesPlugin,
  coreQueriesPluginToolNames,
  coreSCSPlugin,
  coreSCSPluginToolNames,
  coreTokenPlugin,
  coreTokenPluginToolNames,
  coreTokenQueryPlugin,
  coreTokenQueryPluginToolNames,
  coreTransactionQueryPlugin,
  coreTransactionQueryPluginToolNames,
  getERC20FactoryAddress,
  getERC721FactoryAddress,
  handleTransaction
};
//# sourceMappingURL=index.mjs.map